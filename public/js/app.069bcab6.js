(function(){"use strict";var e={1691:function(e,n,t){var i=t(5130),r=t(2261),a=t(6768);const s={class:"app-container"},l={class:"main-nav"},o={class:"container nav-container"},u={class:"main-content"},d={class:"container"};function c(e,n,t,i,r,c){const h=(0,a.g2)("router-link"),k=(0,a.g2)("router-view");return(0,a.uX)(),(0,a.CE)("div",s,[n[4]||(n[4]=(0,a.Lk)("header",{class:"app-header"},[(0,a.Lk)("div",{class:"container"},[(0,a.Lk)("h1",{class:"app-title"},"Java Speicherverwaltung"),(0,a.Lk)("p",{class:"app-subtitle"},"Interaktive Visualisierung der Java-Speicherkonzepte")])],-1)),(0,a.Lk)("nav",l,[(0,a.Lk)("div",o,[(0,a.bF)(h,{to:"/",class:"nav-item","exact-active-class":"active"},{default:(0,a.k6)((()=>n[0]||(n[0]=[(0,a.Lk)("div",{class:"nav-icon"},[(0,a.Lk)("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"24",height:"24",fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[(0,a.Lk)("path",{d:"M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"}),(0,a.Lk)("polyline",{points:"9 22 9 12 15 12 15 22"})])],-1),(0,a.Lk)("span",null,"Home",-1)]))),_:1}),(0,a.bF)(h,{to:"/visualizer",class:"nav-item","active-class":"active"},{default:(0,a.k6)((()=>n[1]||(n[1]=[(0,a.Lk)("div",{class:"nav-icon"},[(0,a.Lk)("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"24",height:"24",fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[(0,a.Lk)("rect",{x:"2",y:"3",width:"20",height:"14",rx:"2",ry:"2"}),(0,a.Lk)("line",{x1:"8",y1:"21",x2:"16",y2:"21"}),(0,a.Lk)("line",{x1:"12",y1:"17",x2:"12",y2:"21"})])],-1),(0,a.Lk)("span",null,"Visualisierung",-1)]))),_:1}),(0,a.bF)(h,{to:"/theory",class:"nav-item","active-class":"active"},{default:(0,a.k6)((()=>n[2]||(n[2]=[(0,a.Lk)("div",{class:"nav-icon"},[(0,a.Lk)("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"24",height:"24",fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[(0,a.Lk)("path",{d:"M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"}),(0,a.Lk)("path",{d:"M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"})])],-1),(0,a.Lk)("span",null,"Theory & Concepts",-1)]))),_:1}),(0,a.bF)(h,{to:"/quiz",class:"nav-item","active-class":"active"},{default:(0,a.k6)((()=>n[3]||(n[3]=[(0,a.Lk)("div",{class:"nav-icon"},[(0,a.Lk)("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"24",height:"24",fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[(0,a.Lk)("circle",{cx:"12",cy:"12",r:"10"}),(0,a.Lk)("line",{x1:"12",y1:"16",x2:"12",y2:"12"}),(0,a.Lk)("line",{x1:"12",y1:"8",x2:"12",y2:"8"})])],-1),(0,a.Lk)("span",null,"Quiz",-1)]))),_:1})])]),(0,a.Lk)("main",u,[(0,a.Lk)("div",d,[(0,a.bF)(k)])])])}var h={name:"App"},k=t(1241);const p=(0,k.A)(h,[["render",c]]);var m=p,g=t(1387);const v={class:"visualizer-container"},L={class:"visualizer-grid"},b={class:"left-panel"},f={class:"right-panel"};function w(e,n,t,i,r,s){const l=(0,a.g2)("CodeExplorer"),o=(0,a.g2)("MemoryVisualizer");return(0,a.uX)(),(0,a.CE)("div",v,[(0,a.Lk)("div",L,[(0,a.Lk)("div",b,[(0,a.bF)(l)]),(0,a.Lk)("div",f,[(0,a.bF)(o)])])])}var S=t(4232);const z={class:"code-explorer"},y={class:"code-container"},A={key:0,class:"instruction-pointer-arrow"},W={key:1,class:"line-spacer"},B={class:"line-number"},x={class:"line-content"},M={class:"controls"},C=["disabled"];function O(e,n,t,i,r,s){return(0,a.uX)(),(0,a.CE)("div",z,[n[5]||(n[5]=(0,a.Lk)("h2",null,"Java Code",-1)),(0,a.Lk)("div",y,[((0,a.uX)(!0),(0,a.CE)(a.FK,null,(0,a.pI)(i.codeLines,((e,n)=>((0,a.uX)(),(0,a.CE)("div",{key:n,class:(0,S.C4)(["code-line",{"active-line":i.store.currentLine===n}])},[i.store.nextLineToExecute===n?((0,a.uX)(),(0,a.CE)("div",A," ▶ ")):((0,a.uX)(),(0,a.CE)("div",W)),(0,a.Lk)("span",B,(0,S.v_)(n+1),1),(0,a.Lk)("span",x,(0,S.v_)(e),1)],2)))),128))]),(0,a.Lk)("div",M,[(0,a.Lk)("button",{onClick:n[0]||(n[0]=(...e)=>i.previousLine&&i.previousLine(...e)),class:"btn btn-secondary",disabled:!i.store.canGoBack},n[3]||(n[3]=[(0,a.Lk)("svg",{xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 24 24",fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[(0,a.Lk)("polyline",{points:"15 18 9 12 15 6"})],-1),(0,a.eW)(" Previous Step ")]),8,C),(0,a.Lk)("button",{onClick:n[1]||(n[1]=(...e)=>i.nextLine&&i.nextLine(...e)),class:"btn"},n[4]||(n[4]=[(0,a.eW)(" Next Step "),(0,a.Lk)("svg",{xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 24 24",fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[(0,a.Lk)("polyline",{points:"9 18 15 12 9 6"})],-1)])),(0,a.Lk)("button",{onClick:n[2]||(n[2]=(...e)=>i.reset&&i.reset(...e)),class:"btn btn-reset"},"Reset")])])}t(4114);const P=(0,r.nY)("memory",{state:()=>({currentLine:0,nextLineToExecute:1,stackVariables:[],heapObjects:[],stackPointer:-1,history:[],canGoBack:!1,programCompleted:!1,currentCode:'public class Example {\n    public static void main(String[] args) {\n        int x = 5;\n        String message = "Hello";\n        System.out.println(message + " World!");\n    }\n}'}),actions:{saveState(){this.history.push({currentLine:this.currentLine,nextLineToExecute:this.nextLineToExecute,stackVariables:JSON.parse(JSON.stringify(this.stackVariables||[])),heapObjects:JSON.parse(JSON.stringify(this.heapObjects||[])),stackPointer:this.stackPointer,programCompleted:this.programCompleted}),this.canGoBack=!0},nextLine(){this.saveState();const e=this.currentCode.split("\n").length;return!this.programCompleted&&this.nextLineToExecute<e&&(this.currentLine=this.nextLineToExecute,this.currentLine<e-1?this.nextLineToExecute=this.currentLine+1:this.programCompleted=!0,2===this.currentLine?(this.stackVariables.push({name:"x",value:5,address:"0x001",type:"int"}),this.stackPointer=0):3===this.currentLine&&(this.stackVariables.push({name:"message",value:"@0x123",address:"0x002",type:"String"}),this.heapObjects.push({id:"0x123",type:"String",content:"Hello",size:5}),this.stackPointer=1),!0)},previousLine(){if(this.history&&this.history.length>0){const e=this.history.pop();return this.currentLine=e.currentLine,this.nextLineToExecute=e.nextLineToExecute,this.stackVariables=e.stackVariables,this.heapObjects=e.heapObjects,this.stackPointer=e.stackPointer,this.programCompleted=e.programCompleted,this.canGoBack=this.history.length>0,!0}return this.canGoBack=!1,!1},reset(){this.currentLine=0,this.nextLineToExecute=1,this.stackPointer=-1,this.stackVariables=[],this.heapObjects=[],this.history=[],this.canGoBack=!1,this.programCompleted=!1}}});var j={name:"CodeExplorer",emits:["next-step","prev-step","reset"],setup(e,{emit:n}){const t=P(),i=(0,a.EW)((()=>t.currentCode.split("\n"))),r=()=>{const e=t.nextLine();e&&n("next-step")},s=()=>{const e=t.previousLine();e&&n("prev-step")},l=()=>{t.reset(),n("reset")};return(0,a.sV)((()=>{t.reset()})),{store:t,codeLines:i,nextLine:r,previousLine:s,reset:l}}};const E=(0,k.A)(j,[["render",O],["__scopeId","data-v-db0b5e8c"]]);var D=E;const I={class:"memory-visualizer"},V={class:"memory-sections"},H={class:"memory-section"},F={class:"stack-area"},J={class:"stack-var-name"},_={class:"stack-var-value"},q={key:0},R={key:1,class:"reference"},K={class:"stack-var-type"},T={class:"stack-var-address"},G={key:0,class:"empty-message"},Q={class:"memory-section"},X={class:"heap-area"},Z={class:"object-header"},N={class:"object-content"},$={class:"object-size"},U={key:0,class:"empty-message"},Y={class:"pointers"},ee={class:"pointer"},ne={class:"pointer-value"},te={class:"pointer"},ie={class:"pointer-value"};function re(e,n,t,i,r,s){return(0,a.uX)(),(0,a.CE)("div",I,[n[4]||(n[4]=(0,a.Lk)("h2",null,"Speichervisualisierung",-1)),(0,a.Lk)("div",V,[(0,a.Lk)("div",H,[n[0]||(n[0]=(0,a.Lk)("h3",null,"Stack",-1)),(0,a.Lk)("div",F,[((0,a.uX)(!0),(0,a.CE)(a.FK,null,(0,a.pI)(i.store.stackVariables,((e,n)=>((0,a.uX)(),(0,a.CE)("div",{key:n,class:(0,S.C4)(["stack-frame",{"active-frame":i.store.stackPointer===n}])},[(0,a.Lk)("div",J,(0,S.v_)(e.name),1),(0,a.Lk)("div",_,["String"!==e.type?((0,a.uX)(),(0,a.CE)("span",q,(0,S.v_)(e.value),1)):((0,a.uX)(),(0,a.CE)("span",R,(0,S.v_)(e.value),1))]),(0,a.Lk)("div",K,(0,S.v_)(e.type),1),(0,a.Lk)("div",T,(0,S.v_)(e.address),1)],2)))),128)),0===i.store.stackVariables.length?((0,a.uX)(),(0,a.CE)("div",G," Stack ist leer ")):(0,a.Q3)("",!0)])]),(0,a.Lk)("div",Q,[n[1]||(n[1]=(0,a.Lk)("h3",null,"Heap",-1)),(0,a.Lk)("div",X,[((0,a.uX)(!0),(0,a.CE)(a.FK,null,(0,a.pI)(i.store.heapObjects,(e=>((0,a.uX)(),(0,a.CE)("div",{key:e.id,class:"heap-object"},[(0,a.Lk)("div",Z,(0,S.v_)(e.type)+" ("+(0,S.v_)(e.id)+")",1),(0,a.Lk)("div",N,'"'+(0,S.v_)(e.content)+'"',1),(0,a.Lk)("div",$,"Size: "+(0,S.v_)(e.size)+" bytes",1)])))),128)),0===i.store.heapObjects.length?((0,a.uX)(),(0,a.CE)("div",U," Heap ist leer ")):(0,a.Q3)("",!0)])])]),(0,a.Lk)("div",Y,[(0,a.Lk)("div",ee,[n[2]||(n[2]=(0,a.Lk)("span",{class:"pointer-label"},"Instruction Pointer (IP):",-1)),(0,a.Lk)("span",ne,(0,S.v_)(i.store.programCompleted?"Programm beendet":"Line "+(i.store.nextLineToExecute+1)),1)]),(0,a.Lk)("div",te,[n[3]||(n[3]=(0,a.Lk)("span",{class:"pointer-label"},"Stack Pointer (SP):",-1)),(0,a.Lk)("span",ie,(0,S.v_)(i.store.stackPointer>=0?`Variable ${i.store.stackVariables[i.store.stackPointer]?.name}`:"None"),1)])])])}var ae={name:"MemoryVisualizer",setup(){const e=P();return{store:e}}};const se=(0,k.A)(ae,[["render",re],["__scopeId","data-v-530ce7b4"]]);var le=se,oe={name:"MainLayout",components:{CodeExplorer:D,MemoryVisualizer:le}};const ue=(0,k.A)(oe,[["render",w],["__scopeId","data-v-5e242d61"]]);var de=ue;const ce={class:"welcome-container"},he={class:"welcome-content-container"},ke={class:"welcome-card preview-section"},pe={class:"visualizer-preview"},me={key:0,class:"preview-placeholder"},ge={class:"welcome-footer"};function ve(e,n,t,i,r,s){return(0,a.uX)(),(0,a.CE)("div",ce,[n[7]||(n[7]=(0,a.Lk)("div",{class:"welcome-header"},[(0,a.Lk)("h1",null,"Willkommen zur Java Speicherverwaltung"),(0,a.Lk)("p",{class:"subtitle"},"Ein interaktives Lernwerkzeug")],-1)),(0,a.Lk)("div",he,[n[4]||(n[4]=(0,a.Fv)('<div class="welcome-card about-section" data-v-76a7d495><h2 data-v-76a7d495>Über dieses Projekt</h2><p data-v-76a7d495> Diese Anwendung wurde im Rahmen des Moduls &quot;Informatik und Programmieren 2&quot; (IIP2) an der Hochschule Luzern entwickelt. Sie dient als interaktives Lernwerkzeug, um die Speicherverwaltungskonzepte in Java besser zu verstehen. </p><p data-v-76a7d495> Durch visuelle Darstellungen und interaktive Elemente möchten wir komplexe Konzepte wie Stack- und Heap-Speicher, Instruction Pointer, Stack Frames und Objektreferenzen anschaulich vermitteln. </p></div><div class="welcome-card features-section" data-v-76a7d495><h2 data-v-76a7d495>Funktionen der Anwendung</h2><div class="features-grid" data-v-76a7d495><div class="feature-item" data-v-76a7d495><div class="feature-icon" data-v-76a7d495><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-v-76a7d495><polyline points="16 18 22 12 16 6" data-v-76a7d495></polyline><polyline points="8 6 2 12 8 18" data-v-76a7d495></polyline></svg></div><h3 data-v-76a7d495>Code Explorer</h3><p data-v-76a7d495>Zeigt Java-Code mit Syntaxhervorhebung. Ein blinkender Pfeil markiert die nächste auszuführende Zeile. </p></div><div class="feature-item" data-v-76a7d495><div class="feature-icon" data-v-76a7d495><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-v-76a7d495><rect x="2" y="2" width="20" height="8" rx="2" ry="2" data-v-76a7d495></rect><rect x="2" y="14" width="20" height="8" rx="2" ry="2" data-v-76a7d495></rect><line x1="6" y1="6" x2="6" y2="6" data-v-76a7d495></line><line x1="6" y1="18" x2="6" y2="18" data-v-76a7d495></line></svg></div><h3 data-v-76a7d495>Memory Visualizer</h3><p data-v-76a7d495>Stellt Stack und Heap in Echtzeit dar. Zeigt Variablen, Objekte und Referenzen während der Code-Ausführung.</p></div><div class="feature-item" data-v-76a7d495><div class="feature-icon" data-v-76a7d495><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-v-76a7d495><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2" data-v-76a7d495></polygon></svg></div><h3 data-v-76a7d495>Schrittweise Ausführung</h3><p data-v-76a7d495>Führe den Code Zeile für Zeile aus, gehe vor und zurück, und beobachte die Änderungen im Speicher.</p></div><div class="feature-item" data-v-76a7d495><div class="feature-icon" data-v-76a7d495><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-v-76a7d495><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z" data-v-76a7d495></path><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z" data-v-76a7d495></path></svg></div><h3 data-v-76a7d495>Theorie &amp; Konzepte</h3><p data-v-76a7d495>Lerne die theoretischen Grundlagen zu Stack, Heap, Call Stack und anderen wichtigen Java-Speicherkonzepten.</p></div></div></div>',2)),(0,a.Lk)("div",ke,[n[3]||(n[3]=(0,a.Lk)("h2",null,"Vorschau der Visualisierung",-1)),(0,a.Lk)("div",pe,[(0,a.Lk)("img",{src:"/visualizer-preview.png",class:"preview-image",alt:"Java Speicherverwaltung Visualisierung",onError:n[0]||(n[0]=(...e)=>s.handleImageError&&s.handleImageError(...e))},null,32),r.imageError?((0,a.uX)(),(0,a.CE)("div",me,n[2]||(n[2]=[(0,a.Fv)('<div class="mockup-container" data-v-76a7d495><div class="mockup-code-panel" data-v-76a7d495><div class="mockup-code-header" data-v-76a7d495>Java Code</div><div class="mockup-code-lines" data-v-76a7d495><div class="mockup-code-line" data-v-76a7d495><span class="line-num" data-v-76a7d495>1</span> <span class="code-keyword" data-v-76a7d495>public</span><span class="code-keyword" data-v-76a7d495>class</span> <span class="code-class" data-v-76a7d495>Example</span> { </div><div class="mockup-code-line" data-v-76a7d495><span class="line-num" data-v-76a7d495>2</span> <span class="code-keyword" data-v-76a7d495>public</span><span class="code-keyword" data-v-76a7d495>static</span> <span class="code-keyword" data-v-76a7d495>void</span> <span class="code-method" data-v-76a7d495>main</span>(<span class="code-class" data-v-76a7d495>String</span>[] args) { </div><div class="mockup-code-line active-line" data-v-76a7d495><span class="line-spacer" data-v-76a7d495></span><span class="line-num" data-v-76a7d495>3</span><span class="code-keyword" data-v-76a7d495>int</span> x = 5; </div><div class="mockup-code-line" data-v-76a7d495><span class="ip-arrow" data-v-76a7d495>▶</span><span class="line-num" data-v-76a7d495>4</span><span class="code-class" data-v-76a7d495>String</span> message = <span class="code-string" data-v-76a7d495>&quot;Hello&quot;</span>; </div><div class="mockup-code-line" data-v-76a7d495><span class="line-spacer" data-v-76a7d495></span><span class="line-num" data-v-76a7d495>5</span> <span class="code-class" data-v-76a7d495>System</span>.out.println(message + <span class="code-string" data-v-76a7d495>&quot; World!&quot;</span>);</div><div class="mockup-code-line" data-v-76a7d495><span class="line-spacer" data-v-76a7d495></span><span class="line-num" data-v-76a7d495>6</span> }</div><div class="mockup-code-line" data-v-76a7d495><span class="line-spacer" data-v-76a7d495></span><span class="line-num" data-v-76a7d495>7</span> }</div></div><div class="mockup-controls" data-v-76a7d495><button class="mockup-button prev" data-v-76a7d495>← Previous Step</button><button class="mockup-button next" data-v-76a7d495>Next Step →</button><button class="mockup-button reset" data-v-76a7d495>Reset</button></div></div><div class="mockup-memory-panel" data-v-76a7d495><div class="mockup-memory-header" data-v-76a7d495>Speicherzustand</div><div class="mockup-memory-stack" data-v-76a7d495><div class="mockup-stack-header" data-v-76a7d495>Stack</div><div class="mockup-stack-var" data-v-76a7d495><div data-v-76a7d495>x: int</div><div data-v-76a7d495>5</div></div><div class="mockup-pointer" data-v-76a7d495>SP</div></div><div class="mockup-memory-heap" data-v-76a7d495><div class="mockup-heap-header" data-v-76a7d495>Heap</div><div class="mockup-heap-empty" data-v-76a7d495>Heap ist leer</div></div><div class="mockup-ip" data-v-76a7d495><span data-v-76a7d495>Instruction Pointer: Zeile 4</span></div></div></div><div class="preview-caption" data-v-76a7d495>Interaktive Visualisierung der Java-Speicherverwaltung</div>',2)]))):(0,a.Q3)("",!0)])]),n[5]||(n[5]=(0,a.Fv)('<div class="welcome-card usage-section" data-v-76a7d495><h2 data-v-76a7d495>So verwendest du die Anwendung</h2><ol class="usage-steps" data-v-76a7d495><li data-v-76a7d495><strong data-v-76a7d495>1. Code anschauen</strong><p data-v-76a7d495>Auf der linken Seite siehst du den Java-Code, der ausgeführt wird.</p></li><li data-v-76a7d495><strong data-v-76a7d495>2. Durch den Code navigieren</strong><p data-v-76a7d495>Verwende die Buttons &quot;Next Step&quot; und &quot;Previous Step&quot;, um durch den Code zu navigieren.</p></li><li data-v-76a7d495><strong data-v-76a7d495>3. Speicheränderungen beobachten</strong><p data-v-76a7d495>Auf der rechten Seite kannst du sehen, wie sich der Speicherzustand mit jedem Schritt verändert.</p></li><li data-v-76a7d495><strong data-v-76a7d495>4. Theorie erkunden</strong><p data-v-76a7d495>Besuche den &quot;Theory &amp; Concepts&quot; Bereich, um mehr über die Speicherverwaltung in Java zu lernen.</p></li></ol></div>',1))]),(0,a.Lk)("div",ge,[(0,a.Lk)("button",{onClick:n[1]||(n[1]=(...e)=>s.startVisualizer&&s.startVisualizer(...e)),class:"start-button"},n[6]||(n[6]=[(0,a.eW)(" Zur Visualisierung "),(0,a.Lk)("svg",{xmlns:"http://www.w3.org/2000/svg",width:"20",height:"20",viewBox:"0 0 24 24",fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[(0,a.Lk)("line",{x1:"5",y1:"12",x2:"19",y2:"12"}),(0,a.Lk)("polyline",{points:"12 5 19 12 12 19"})],-1)]))])])}var Le={name:"WelcomePage",data(){return{imageError:!1}},methods:{startVisualizer(){this.$router.push("/visualizer")},handleImageError(){this.imageError=!0}}};const be=(0,k.A)(Le,[["render",ve],["__scopeId","data-v-76a7d495"]]);var fe=be;const we={class:"theory-container"},Se={class:"card-grid"},ze=["onClick"],ye={class:"concept-title"},Ae={class:"concept-description"};function We(e,n,t,i,r,s){return(0,a.uX)(),(0,a.CE)("div",we,[n[1]||(n[1]=(0,a.Lk)("h2",{class:"theory-heading"},"Theory & Concepts",-1)),(0,a.Lk)("div",Se,[((0,a.uX)(!0),(0,a.CE)(a.FK,null,(0,a.pI)(r.theoryCards,((e,t)=>((0,a.uX)(),(0,a.CE)("div",{key:t,class:"concept-card",onClick:n=>s.showTheoryDetail(e.id)},[(0,a.Lk)("h3",ye,(0,S.v_)(e.title),1),(0,a.Lk)("p",Ae,(0,S.v_)(e.shortDescription),1),n[0]||(n[0]=(0,a.Lk)("div",{class:"card-footer"},[(0,a.Lk)("span",{class:"read-more"},"Mehr lesen →")],-1))],8,ze)))),128))])])}var Be={name:"TheoryCards",data(){return{theoryCards:[{id:"memory-heap",title:"Memory Heap",shortDescription:"The heap is where objects are stored. When you create an object using 'new', it's allocated on the heap."},{id:"memory-stack",title:"Memory Stack",shortDescription:"The stack stores local variables and method call information. Each thread has its own stack."},{id:"callstack",title:"Call Stack",shortDescription:"The call stack keeps track of method calls. Each method call creates a new frame on the stack."},{id:"stack-pointer",title:"Stack Pointer",shortDescription:"Points to the top of the stack, indicating the current execution context."},{id:"instruction-pointer",title:"Instruction Pointer",shortDescription:"Points to the next instruction to be executed in the program."},{id:"method-area",title:"Method Area",shortDescription:"Stores class structures, method code, and constant pool information."}]}},methods:{showTheoryDetail(e){this.$router.push({name:`theory-${e}`})}}};const xe=(0,k.A)(Be,[["render",We],["__scopeId","data-v-c0ca89f0"]]);var Me=xe;const Ce={class:"quiz-container"},Oe={key:0,class:"quit-button-container"},Pe={key:1,class:"quiz-intro"},je={class:"intro-content"},Ee={key:2,class:"quiz-question-container"},De={class:"quiz-progress"},Ie={class:"progress-bar"},Ve={class:"progress-text"},He={class:"question-card"},Fe={class:"question-text"},Je={class:"options-list"},_e=["onClick"],qe={class:"option-marker"},Re={class:"option-text"},Ke={key:0,class:"feedback-container"},Te={class:"feedback-icon"},Ge={class:"feedback-text"},Qe={key:1,class:"action-container"},Xe=["disabled"],Ze={key:3,class:"quiz-results"},Ne={class:"score-display"},$e={class:"score-circle"},Ue={key:0,class:"score-percentage"},Ye={key:1,class:"score-percentage"},en={class:"result-feedback"},nn={key:0},tn={key:1},rn={key:2},an={key:3},sn={key:4},ln={key:5},on={class:"result-actions"};function un(e,n,t,i,r,s){const l=(0,a.g2)("router-link");return(0,a.uX)(),(0,a.CE)("div",Ce,[r.quizStarted&&!r.quizCompleted?((0,a.uX)(),(0,a.CE)("div",Oe,[(0,a.Lk)("button",{onClick:n[0]||(n[0]=(...e)=>s.endQuiz&&s.endQuiz(...e)),class:"quiz-button quit-button","data-tooltip":"Quiz frühzeitig beenden"},"X")])):(0,a.Q3)("",!0),n[9]||(n[9]=(0,a.Lk)("h1",{class:"quiz-title"},"Speicherverwaltung in Java: Quiz",-1)),r.quizStarted?r.quizCompleted?((0,a.uX)(),(0,a.CE)("div",Ze,[n[8]||(n[8]=(0,a.Lk)("h2",null,"Quiz abgeschlossen!",-1)),(0,a.Lk)("div",Ne,[(0,a.Lk)("div",$e,(0,S.v_)(r.score)+" / "+(0,S.v_)(r.answeredQuestions),1),r.answeredQuestions>0?((0,a.uX)(),(0,a.CE)("p",Ue,(0,S.v_)(Math.round(r.score/r.answeredQuestions*100))+"% ",1)):((0,a.uX)(),(0,a.CE)("p",Ye," Es wurde noch keine Fragen beantwortet. "))]),(0,a.Lk)("div",en,[r.answeredQuestions===r.questions.length&&r.score===r.questions.length?((0,a.uX)(),(0,a.CE)("p",nn,"Perfekt! Du beherrschst die Speicherverwaltung in Java!")):r.answeredQuestions===r.questions.length&&r.score/r.answeredQuestions>=.8?((0,a.uX)(),(0,a.CE)("p",tn,"Sehr gut! Du verstehst die meisten Konzepte der Speicherverwaltung.")):r.answeredQuestions===r.questions.length&&r.score/r.answeredQuestions>=.6?((0,a.uX)(),(0,a.CE)("p",rn,"Gut gemacht! Du hast ein solides Grundverständnis.")):r.answeredQuestions===r.questions.length?((0,a.uX)(),(0,a.CE)("p",an,"Du solltest die Theorie nochmal wiederholen, um dein Wissen zu vertiefen.")):r.answeredQuestions>0?((0,a.uX)(),(0,a.CE)("p",sn,"Du hast "+(0,S.v_)(r.score)+" von "+(0,S.v_)(r.answeredQuestions)+" Fragen richtig beantwortet.",1)):((0,a.uX)(),(0,a.CE)("p",ln,"Du hast das Quiz vorzeitig beendet."))]),(0,a.Lk)("div",on,[(0,a.Lk)("button",{onClick:n[4]||(n[4]=(...e)=>s.restartQuiz&&s.restartQuiz(...e)),class:"quiz-button"},"Quiz wiederholen"),(0,a.bF)(l,{to:"/theory",class:"theory-link"},{default:(0,a.k6)((()=>n[7]||(n[7]=[(0,a.eW)("Zurück zur Theorie")]))),_:1})])])):((0,a.uX)(),(0,a.CE)("div",Ee,[(0,a.Lk)("div",De,[(0,a.Lk)("div",Ie,[(0,a.Lk)("div",{class:"progress-fill",style:(0,S.Tr)({width:`${s.progress}%`})},null,4)]),(0,a.Lk)("div",Ve,"Frage "+(0,S.v_)(r.currentQuestionIndex+1)+" von "+(0,S.v_)(r.questions.length),1)]),(0,a.Lk)("div",He,[(0,a.Lk)("h2",Fe,(0,S.v_)(s.currentQuestion.question),1),(0,a.Lk)("div",Je,[((0,a.uX)(!0),(0,a.CE)(a.FK,null,(0,a.pI)(s.currentQuestion.options,((e,n)=>((0,a.uX)(),(0,a.CE)("div",{key:n,class:(0,S.C4)(["option-item",{selected:r.selectedOption===n,correct:r.showAnswer&&n===s.currentQuestion.correctAnswer,incorrect:r.showAnswer&&r.selectedOption===n&&n!==s.currentQuestion.correctAnswer}]),onClick:e=>s.selectOption(n)},[(0,a.Lk)("span",qe,(0,S.v_)(["A","B","C","D"][n]),1),(0,a.Lk)("span",Re,(0,S.v_)(e),1)],10,_e)))),128))]),r.showAnswer?((0,a.uX)(),(0,a.CE)("div",Ke,[(0,a.Lk)("div",{class:(0,S.C4)(["feedback",s.isCorrect?"correct-feedback":"incorrect-feedback"])},[(0,a.Lk)("div",Te,(0,S.v_)(s.isCorrect?"✓":"✗"),1),(0,a.Lk)("div",Ge,[(0,a.Lk)("p",null,[(0,a.Lk)("strong",null,(0,S.v_)(s.isCorrect?"Richtig!":"Falsch!"),1)]),(0,a.Lk)("p",null,(0,S.v_)(s.currentQuestion.explanation),1)])],2),(0,a.Lk)("button",{onClick:n[2]||(n[2]=(...e)=>s.nextQuestion&&s.nextQuestion(...e)),class:"quiz-button"},(0,S.v_)(r.currentQuestionIndex<r.questions.length-1?"Nächste Frage":"Ergebnis anzeigen"),1)])):((0,a.uX)(),(0,a.CE)("div",Qe,[(0,a.Lk)("button",{onClick:n[3]||(n[3]=(...e)=>s.checkAnswer&&s.checkAnswer(...e)),class:"quiz-button",disabled:null===r.selectedOption},"Antwort prüfen",8,Xe)]))])])):((0,a.uX)(),(0,a.CE)("div",Pe,[(0,a.Lk)("div",je,[n[5]||(n[5]=(0,a.Lk)("p",null,"Teste dein Wissen über die Speicherverwaltung in Java mit diesem kurzen Quiz!",-1)),(0,a.Lk)("p",null,"Das Quiz besteht aus "+(0,S.v_)(r.questions.length)+" Fragen zu den wichtigsten Konzepten:",1),n[6]||(n[6]=(0,a.Lk)("ul",null,[(0,a.Lk)("li",null,"Call Stack"),(0,a.Lk)("li",null,"Memory Heap"),(0,a.Lk)("li",null,"Stack Pointer"),(0,a.Lk)("li",null,"Instruction Pointer"),(0,a.Lk)("li",null,"Method Area")],-1))]),(0,a.Lk)("button",{onClick:n[1]||(n[1]=(...e)=>s.startQuiz&&s.startQuiz(...e)),class:"quiz-button start-button"},"Quiz starten")]))])}var dn={name:"QuizPage",data(){return{quizStarted:!1,quizCompleted:!1,currentQuestionIndex:0,selectedOption:null,showAnswer:!1,score:0,answeredQuestions:0,originalQuestions:[{question:"Was ist der Call Stack?",options:["Ein Speicherbereich für dynamisch erzeugte Objekte","Eine Datenstruktur zur Verfolgung von Methodenaufrufen","Ein Bereich zur Speicherung von statischen Variablen","Ein Register, das auf den aktuellen Speicherbereich zeigt"],correctAnswer:1,explanation:"Der Call Stack ist eine Datenstruktur, die von der JVM verwendet wird, um den Ausführungsverlauf von Methodenaufrufen zu verfolgen."},{question:"Welche Daten werden im Memory Heap gespeichert?",options:["Nur primitive Datentypen wie int und boolean","Nur lokale Variablen einer Methode","Objekte und Arrays","Nur statische Variablen"],correctAnswer:2,explanation:"Der Memory Heap ist ein dynamischer Speicherbereich, in dem Objekte und Arrays gespeichert werden."},{question:"Was passiert, wenn der Stack voll ist?",options:["OutOfMemoryError wird ausgelöst","StackOverflowError wird ausgelöst","Die JVM erstellt automatisch einen neuen Stack","Der Garbage Collector gibt Speicher frei"],correctAnswer:1,explanation:"Wenn der Stack voll ist, wird ein StackOverflowError ausgelöst, häufig durch zu tiefe Rekursionen."},{question:"Was zeigt der Stack Pointer an?",options:["Die nächste auszuführende Anweisung im Bytecode","Die Grösse des verfügbaren Heap-Speichers","Die aktuelle Position im Call Stack","Die Adresse des zuletzt erstellten Objekts"],correctAnswer:2,explanation:"Der Stack Pointer ist ein Register, das auf die aktuelle Position im Stack zeigt und bei jedem Methodenaufruf aktualisiert wird."},{question:"Was ist die Aufgabe des Instruction Pointers?",options:["Er zeigt auf die nächste auszuführende Bytecode-Instruktion","Er verwaltet die Speicherbelegung im Heap","Er identifiziert nicht mehr benötigte Objekte für den Garbage Collector","Er speichert die Adressen aller statischen Variablen"],correctAnswer:0,explanation:"Der Instruction Pointer (Program Counter) zeigt auf die nächste auszuführende Bytecode-Instruktion und steuert den Programmfluss."},{question:"Was wird in der Method Area gespeichert?",options:["Nur lokale Variablen einer Methode","Nur Objekte und ihre Instanzvariablen","Klassenmetadaten, statische Variablen und Bytecode","Nur Referenzvariablen, die auf den Heap zeigen"],correctAnswer:2,explanation:"Die Method Area enthält Klassenmetadaten, statische Variablen und den kompilierten Bytecode aller Methoden."},{question:"Was ist NICHT im Stack Frame enthalten?",options:["Lokale Variablen","Parameter der Methode","Instanzvariablen eines Objekts","Rücksprungadresse"],correctAnswer:2,explanation:"Instanzvariablen sind Teil eines Objekts und werden im Heap gespeichert, nicht im Stack Frame."},{question:"Welche Aussage zum Garbage Collector ist korrekt?",options:["Er gibt den Speicher von lokalen Variablen im Stack frei","Er befreit nicht mehr referenzierte Objekte im Heap","Er muss manuell vom Programmierer aufgerufen werden","Er komprimiert Stack und Heap gleichermassen"],correctAnswer:1,explanation:"Der Garbage Collector identifiziert und entfernt Objekte im Heap, auf die keine Referenzen mehr zeigen."},{question:"Warum ist der Zugriff auf den Stack schneller als auf den Heap?",options:["Weil der Stack kleiner ist als der Heap","Weil der Stack in einem speziellen Cache gespeichert wird","Weil der Stack nach dem LIFO-Prinzip arbeitet und vorhersehbare Adressierungsmuster hat","Weil der Stack nur primitive Datentypen enthält"],correctAnswer:2,explanation:"Der Stack ist schneller, weil er nach dem LIFO-Prinzip arbeitet und dadurch vorhersehbare Speicheradressierungen ermöglicht."},{question:"Was passiert mit lokalen Variablen, wenn eine Methode beendet wird?",options:["Sie bleiben im Stack, bis der Garbage Collector sie entfernt","Sie werden in den Heap verschoben","Sie werden automatisch vom Stack entfernt","Sie werden zu statischen Variablen"],correctAnswer:2,explanation:"Lokale Variablen werden automatisch vom Stack entfernt, wenn die Methode beendet wird und der Stack Frame gelöscht wird."},{question:"Wo werden primitive Datentypen wie int und boolean in Java gespeichert?",options:["Immer im Heap","Immer im Stack","Im Stack als lokale Variablen, im Heap als Objektattribute","In der Method Area"],correctAnswer:2,explanation:"Primitive Datentypen werden im Stack gespeichert, wenn sie lokale Variablen sind. Als Objektattribute (Instanzvariablen) werden sie im Heap als Teil des Objekts gespeichert."},{question:"Was ist String Interning in Java?",options:["Eine Methode, um Strings zu verschlüsseln","Ein Mechanismus, der identische String-Literale im String-Pool wiederverwendet","Eine Technik zum Speichern von Unicode-Zeichen","Ein Prozess zur Optimierung von Stringverkettungen"],correctAnswer:1,explanation:"String Interning ist ein Mechanismus in Java, bei dem identische String-Literale in einem speziellen Bereich (String-Pool) im Heap gespeichert und wiederverwendet werden, um Speicherplatz zu sparen."},{question:"Was ist ein Memory Leak in Java?",options:["Wenn die JVM zu wenig Arbeitsspeicher zugewiesen bekommt","Wenn Objekte erstellt werden, aber nie verwendet werden","Wenn Objekte nicht mehr benötigt werden, aber immer noch referenziert werden","Wenn der Garbage Collector fehlerhaft ist"],correctAnswer:2,explanation:"Ein Memory Leak in Java tritt auf, wenn Objekte nicht mehr benötigt werden, aber weiterhin referenziert werden, sodass der Garbage Collector sie nicht entfernen kann. Dies führt zu unnötigem Speicherverbrauch."},{question:"Was ist der Unterschied zwischen deep copy und shallow copy?",options:["Deep copy ist schneller, shallow copy ist speichereffizienter","Deep copy kopiert alle referenzierten Objekte, shallow copy nur die Referenzen","Deep copy wird für primitive Typen verwendet, shallow copy für Objekte","Deep copy braucht den Garbage Collector, shallow copy nicht"],correctAnswer:1,explanation:"Bei einer shallow copy werden nur die Referenzen kopiert, nicht die referenzierten Objekte selbst. Bei einer deep copy werden auch alle referenzierten Objekte rekursiv kopiert."},{question:"Wann ist ein Objekt für den Garbage Collector bereit zur Entfernung?",options:["Wenn das Objekt explizit mit delete() gelöscht wird","Wenn keine Referenzen mehr auf das Objekt zeigen","Wenn das Objekt die finalize() Methode überschreibt","Wenn das Objekt aus einer Methode zurückkehrt"],correctAnswer:1,explanation:"Ein Objekt ist für den Garbage Collector bereit, wenn keine Referenzen mehr darauf zeigen und es somit nicht mehr erreichbar ist (unreachable)."},{question:"Warum kann der Garbage Collector zu Leistungsproblemen führen?",options:["Er benötigt zusätzlichen Speicher für seine Verwaltungsdaten","Er pausiert die Anwendungsausführung während der Speicherbereinigung","Er verschiebt ständig Objekte im Heap","Er arbeitet mit einer ineffizienten linearen Suche"],correctAnswer:1,explanation:"Der Garbage Collector kann zu Leistungsproblemen führen, weil er für die Speicherbereinigung (insbesondere bei Major GC) die Anwendungsausführung pausieren muss, was zu sogenannten 'Stop-the-World'-Pausen führt."},{question:"Welche Auswirkung hat Autoboxing auf den Speicherverbrauch?",options:["Es reduziert den Speicherverbrauch durch Wiederverwendung von Objekten","Es hat keine Auswirkung auf den Speicherverbrauch","Es erhöht den Speicherverbrauch, da primitive Typen in Objekte umgewandelt werden","Es komprimiert den Speicher durch spezielle JVM-Optimierungen"],correctAnswer:2,explanation:"Autoboxing wandelt primitive Datentypen automatisch in ihre entsprechenden Wrapper-Objekte um (z.B. int zu Integer). Dies erhöht den Speicherverbrauch, da Objekte mehr Speicher benötigen als primitive Typen."},{question:"Was ist das Besondere an der finalize()-Methode?",options:["Sie wird garantiert ausgeführt, wenn ein Objekt aus dem Speicher entfernt wird","Sie erlaubt einem Objekt, sich selbst vor der Garbage Collection zu retten","Sie beschleunigt die Garbage Collection für das Objekt","Sie führt zu einer sofortigen Speicherfreigabe"],correctAnswer:1,explanation:"Die finalize()-Methode wird vom Garbage Collector aufgerufen, bevor ein Objekt entfernt wird, und erlaubt dem Objekt, sich selbst zu 'retten', indem es eine neue Referenz auf sich erstellt. Dies ist jedoch nicht empfohlen und seit Java 9 als veraltet markiert."},{question:"Wie können Anwendungen mit eingeschränktem Speicher optimiert werden?",options:["Durch Verwendung von mehr statischen Methoden","Durch Verwendung von mehr lokalen Variablen anstatt Objektattributen","Durch Verwendung von primitiven Datentypen anstelle von Wrapper-Klassen wo möglich","Durch Bevorzugung von Vererbung gegenüber Komposition"],correctAnswer:2,explanation:"Primitive Datentypen (wie int, boolean) benötigen weniger Speicher als ihre Wrapper-Klassen (Integer, Boolean). Daher kann ihre Verwendung, wo immer möglich, den Speicherverbrauch reduzieren."},{question:"Was passiert mit dem Speicher einer inneren (nicht-statischen) Klasse?",options:["Sie teilt sich den Speicher mit ihrer äusseren Klasse","Sie hat keinen eigenen Speicherbedarf","Sie speichert implizit eine Referenz auf ihre äussere Klasse","Sie wird in einem separaten Speicherbereich ausserhalb von Heap und Stack allokiert"],correctAnswer:2,explanation:"Eine innere (nicht-statische) Klasse speichert implizit eine Referenz auf die Instanz ihrer äusseren Klasse. Dies bedeutet, dass Objekte der äusseren Klasse nicht vom Garbage Collector entfernt werden können, solange Objekte der inneren Klasse existieren."}],questions:[]}},created(){this.questions=[...this.originalQuestions]},computed:{currentQuestion(){return this.questions[this.currentQuestionIndex]},isCorrect(){return this.selectedOption===this.currentQuestion.correctAnswer},progress(){return(this.currentQuestionIndex+1)/this.questions.length*100}},methods:{startQuiz(){this.quizStarted=!0,this.quizCompleted=!1,this.currentQuestionIndex=0,this.score=0,this.answeredQuestions=0,this.selectedOption=null,this.showAnswer=!1,this.shuffleQuestions()},shuffleQuestions(){const e=[...this.originalQuestions];for(let n=e.length-1;n>0;n--){const t=Math.floor(Math.random()*(n+1));[e[n],e[t]]=[e[t],e[n]]}this.questions=e},selectOption(e){this.showAnswer||(this.selectedOption=e)},checkAnswer(){this.showAnswer=!0,this.isCorrect&&this.score++,this.answeredQuestions++},nextQuestion(){this.currentQuestionIndex<this.questions.length-1?(this.currentQuestionIndex++,this.selectedOption=null,this.showAnswer=!1):this.quizCompleted=!0},endQuiz(){this.quizCompleted=!0},restartQuiz(){this.startQuiz()}}};const cn=(0,k.A)(dn,[["render",un],["__scopeId","data-v-14737426"]]);var hn=cn;const kn={class:"theory-content"},pn={class:"interactive-demo"},mn={class:"demo-container"},gn={class:"code-section"},vn={class:"code-example interactive-code"},Ln={class:"stack-section"},bn={class:"stack-container"},fn={class:"output-console"},wn={class:"console-output"},Sn={class:"demo-controls"},zn=["disabled"],yn={class:"step-indicator"},An=["disabled"],Wn={class:"step-description"};function Bn(e,n,t,r,s,l){const o=(0,a.g2)("TheoryLayout");return(0,a.uX)(),(0,a.Wv)(o,{title:"Call Stack"},{default:(0,a.k6)((()=>[(0,a.Lk)("div",kn,[n[29]||(n[29]=(0,a.Lk)("h2",null,"Was ist der Call Stack?",-1)),n[30]||(n[30]=(0,a.Lk)("p",null,"Der Call Stack (Aufrufstapel) ist eine Datenstruktur, die von der Java Virtual Machine (JVM) verwendet wird, um den Ausführungsverlauf von Methodenaufrufen zu verfolgen. ",-1)),n[31]||(n[31]=(0,a.Lk)("div",{class:"visual-container"},[(0,a.Lk)("div",{class:"visual-fallback"},[(0,a.Lk)("pre",null,"          ┌─────────────────────────┐\n          │     main() Frame        │ ← Aktueller Frame\n          ├─────────────────────────┤\n          │     MethodeA() Frame    │\n          ├─────────────────────────┤\n          │     MethodeB() Frame    │\n          └─────────────────────────┘\n          ")])],-1)),n[32]||(n[32]=(0,a.Lk)("h3",null,"Funktionsweise:",-1)),n[33]||(n[33]=(0,a.Lk)("ul",null,[(0,a.Lk)("li",null,"Der Call Stack arbeitet nach dem Last In, First Out-Prinzip (LIFO) - die zuletzt aufgerufene Methode wird als erste beendet."),(0,a.Lk)("li",null,"Jeder Methodenaufruf erzeugt einen neuen Stack Frame, der auf den Call Stack gelegt wird."),(0,a.Lk)("li",null,[(0,a.eW)("Ein Stack Frame enthält: "),(0,a.Lk)("ul",null,[(0,a.Lk)("li",null,"Lokale Variablen der Methode"),(0,a.Lk)("li",null,"Parameter, die an die Methode übergeben wurden"),(0,a.Lk)("li",null,"Rücksprungadresse (wo die Ausführung fortgesetzt wird, wenn die Methode beendet ist)"),(0,a.Lk)("li",null,"Operanden-Stack für Zwischenberechnungen")])]),(0,a.Lk)("li",null,"Wenn eine Methode beendet wird, wird ihr Frame vom Stack entfernt und der Frame der aufrufenden Methode wird wieder aktiv.")],-1)),n[34]||(n[34]=(0,a.Lk)("div",{class:"example-box"},[(0,a.Lk)("h4",null,"Praktisches Beispiel:"),(0,a.Lk)("pre",{class:"code-example"},'        public class CallStackExample {\n          public static void main(String[] args) {\n              System.out.println("Start im main");\n              methodA();\n              System.out.println("Zurück in main");\n          }\n          \n          public static void methodA() {\n              System.out.println("In methodA");\n              methodB();\n              System.out.println("Zurück in methodA");\n          }\n          \n          public static void methodB() {\n              System.out.println("In methodB");\n              // Hier könnte ein weiterer Methodenaufruf stehen\n          }\n        }'),(0,a.Lk)("div",{class:"example-explanation"},[(0,a.Lk)("p",null,[(0,a.Lk)("strong",null,"Call Stack Status während der Ausführung:")]),(0,a.Lk)("ol",null,[(0,a.Lk)("li",null,[(0,a.eW)("Zunächst ist nur der "),(0,a.Lk)("code",null,"main()"),(0,a.eW)("-Frame auf dem Stack")]),(0,a.Lk)("li",null,[(0,a.eW)("Nach Aufruf von "),(0,a.Lk)("code",null,"methodA()"),(0,a.eW)(" kommt ein Frame für "),(0,a.Lk)("code",null,"methodA()"),(0,a.eW)(" dazu")]),(0,a.Lk)("li",null,[(0,a.eW)("Nach Aufruf von "),(0,a.Lk)("code",null,"methodB()"),(0,a.eW)(" kommt ein Frame für "),(0,a.Lk)("code",null,"methodB()"),(0,a.eW)(" dazu")]),(0,a.Lk)("li",null,[(0,a.eW)("Wenn "),(0,a.Lk)("code",null,"methodB()"),(0,a.eW)(" endet, wird ihr Frame entfernt, und "),(0,a.Lk)("code",null,"methodA()"),(0,a.eW)(" wird wieder aktiv")]),(0,a.Lk)("li",null,[(0,a.eW)("Wenn "),(0,a.Lk)("code",null,"methodA()"),(0,a.eW)(" endet, wird ihr Frame entfernt, und "),(0,a.Lk)("code",null,"main()"),(0,a.eW)(" wird wieder aktiv")])])])],-1)),n[35]||(n[35]=(0,a.Lk)("h3",null,"Der Call Stack in Aktion:",-1)),n[36]||(n[36]=(0,a.Lk)("div",{class:"animation-placeholder"},[(0,a.Lk)("p",null,"Hier seht ihr, wie sich der Call Stack während der Programmausführung Schritt für Schritt verändert:"),(0,a.Lk)("div",{class:"stack-animation-steps"},[(0,a.Lk)("div",{class:"animation-step"},[(0,a.Lk)("div",{class:"step-description"},"1. Programm startet"),(0,a.Lk)("pre",null,"┌─────────────────────────┐\n│     main() Frame        │ ← Aktueller Frame\n└─────────────────────────┘\n            ")]),(0,a.Lk)("div",{class:"animation-step"},[(0,a.Lk)("div",{class:"step-description"},"2. methodA() wird aufgerufen"),(0,a.Lk)("pre",null,"┌─────────────────────────┐\n│     methodA() Frame     │ ← Aktueller Frame\n├─────────────────────────┤\n│     main() Frame        │\n└─────────────────────────┘\n            ")]),(0,a.Lk)("div",{class:"animation-step"},[(0,a.Lk)("div",{class:"step-description"},"3. methodB() wird aufgerufen"),(0,a.Lk)("pre",null,"┌─────────────────────────┐\n│     methodB() Frame     │ ← Aktueller Frame\n├─────────────────────────┤\n│     methodA() Frame     │\n├─────────────────────────┤\n│     main() Frame        │\n└─────────────────────────┘\n            ")]),(0,a.Lk)("div",{class:"animation-step"},[(0,a.Lk)("div",{class:"step-description"},"4. methodB() kehrt zurück"),(0,a.Lk)("pre",null,"┌─────────────────────────┐\n│     methodA() Frame     │ ← Aktueller Frame\n├─────────────────────────┤\n│     main() Frame        │\n└─────────────────────────┘\n            ")]),(0,a.Lk)("div",{class:"animation-step"},[(0,a.Lk)("div",{class:"step-description"},"5. methodA() kehrt zurück"),(0,a.Lk)("pre",null,"┌─────────────────────────┐\n│     main() Frame        │ ← Aktueller Frame\n└─────────────────────────┘\n            ")])])],-1)),n[37]||(n[37]=(0,a.Lk)("h3",null,"Interaktives Beispiel:",-1)),(0,a.Lk)("div",pn,[(0,a.Lk)("div",mn,[(0,a.Lk)("div",gn,[(0,a.Lk)("pre",vn,[n[12]||(n[12]=(0,a.eW)("")),(0,a.Lk)("span",{class:(0,S.C4)({"highlight-method":1===s.currentStep})},"public class CallStackExample {",2),n[13]||(n[13]=(0,a.eW)("\n")),(0,a.Lk)("span",{class:(0,S.C4)({"highlight-method":2===s.currentStep})},[n[2]||(n[2]=(0,a.eW)("    public static void ")),(0,a.Lk)("span",{class:(0,S.C4)({"highlight-active-method":s.currentStep>=2&&s.currentStep<=4||s.currentStep>=14,"highlight-in-stack":s.currentStep>=2})},"main",2),n[3]||(n[3]=(0,a.eW)("(String[] args) {"))],2),n[14]||(n[14]=(0,a.eW)("\n")),(0,a.Lk)("span",{class:(0,S.C4)({"highlight-method":3===s.currentStep})},'        System.out.println("Start im main");',2),n[15]||(n[15]=(0,a.eW)("\n")),(0,a.Lk)("span",{class:(0,S.C4)({"highlight-method":4===s.currentStep})},[n[4]||(n[4]=(0,a.eW)("        ")),(0,a.Lk)("span",{class:(0,S.C4)({"highlight-active-method":4===s.currentStep,"highlight-in-stack":s.currentStep>=5&&s.currentStep<=13})},"methodA",2),n[5]||(n[5]=(0,a.eW)("();"))],2),n[16]||(n[16]=(0,a.eW)("\n")),(0,a.Lk)("span",{class:(0,S.C4)({"highlight-method":14===s.currentStep})},'        System.out.println("Zurück in main");',2),n[17]||(n[17]=(0,a.eW)("\n")),(0,a.Lk)("span",{class:(0,S.C4)({"highlight-method":15===s.currentStep})},"    }",2),n[18]||(n[18]=(0,a.eW)("\n    \n")),(0,a.Lk)("span",{class:(0,S.C4)({"highlight-method":5===s.currentStep})},[n[6]||(n[6]=(0,a.eW)("    public static void ")),(0,a.Lk)("span",{class:(0,S.C4)({"highlight-active-method":s.currentStep>=5&&s.currentStep<=7||s.currentStep>=11&&s.currentStep<=13,"highlight-in-stack":s.currentStep>=5&&s.currentStep<=13})},"methodA",2),n[7]||(n[7]=(0,a.eW)("() {"))],2),n[19]||(n[19]=(0,a.eW)("\n")),(0,a.Lk)("span",{class:(0,S.C4)({"highlight-method":6===s.currentStep})},'        System.out.println("In methodA");',2),n[20]||(n[20]=(0,a.eW)("\n")),(0,a.Lk)("span",{class:(0,S.C4)({"highlight-method":7===s.currentStep})},[n[8]||(n[8]=(0,a.eW)("        ")),(0,a.Lk)("span",{class:(0,S.C4)({"highlight-active-method":7===s.currentStep,"highlight-in-stack":s.currentStep>=8&&s.currentStep<=10})},"methodB",2),n[9]||(n[9]=(0,a.eW)("();"))],2),n[21]||(n[21]=(0,a.eW)("\n")),(0,a.Lk)("span",{class:(0,S.C4)({"highlight-method":12===s.currentStep})},'        System.out.println("Zurück in methodA");',2),n[22]||(n[22]=(0,a.eW)("\n")),(0,a.Lk)("span",{class:(0,S.C4)({"highlight-method":13===s.currentStep})},"    }",2),n[23]||(n[23]=(0,a.eW)("\n    \n")),(0,a.Lk)("span",{class:(0,S.C4)({"highlight-method":8===s.currentStep})},[n[10]||(n[10]=(0,a.eW)("    public static void ")),(0,a.Lk)("span",{class:(0,S.C4)({"highlight-active-method":s.currentStep>=8&&s.currentStep<=10,"highlight-in-stack":s.currentStep>=8&&s.currentStep<=10})},"methodB",2),n[11]||(n[11]=(0,a.eW)("() {"))],2),n[24]||(n[24]=(0,a.eW)("\n")),(0,a.Lk)("span",{class:(0,S.C4)({"highlight-method":9===s.currentStep})},'        System.out.println("In methodB");',2),n[25]||(n[25]=(0,a.eW)("\n")),(0,a.Lk)("span",{class:(0,S.C4)({"highlight-method":10===s.currentStep})},"    }",2),n[26]||(n[26]=(0,a.eW)("\n")),(0,a.Lk)("span",{class:(0,S.C4)({"highlight-method":11===s.currentStep})},"}",2)])]),(0,a.Lk)("div",Ln,[n[28]||(n[28]=(0,a.Lk)("h4",null,"Call Stack:",-1)),(0,a.Lk)("div",bn,[(0,a.bF)(i.F,{name:"stack-frame"},{default:(0,a.k6)((()=>[s.currentStep>=8&&s.currentStep<=10?((0,a.uX)(),(0,a.CE)("div",{key:"methodB",class:(0,S.C4)(["stack-frame",{"active-frame":s.currentStep>=8&&s.currentStep<=10}])}," methodB() Frame ",2)):(0,a.Q3)("",!0),s.currentStep>=5&&s.currentStep<=13?((0,a.uX)(),(0,a.CE)("div",{key:"methodA",class:(0,S.C4)(["stack-frame",{"active-frame":s.currentStep>=5&&s.currentStep<=7||s.currentStep>=11&&s.currentStep<=13}])}," methodA() Frame ",2)):(0,a.Q3)("",!0),s.currentStep>=2&&s.currentStep<=14?((0,a.uX)(),(0,a.CE)("div",{key:"main",class:(0,S.C4)(["stack-frame",{"active-frame":s.currentStep>=2&&s.currentStep<=4||s.currentStep>=14}])}," main() Frame ",2)):(0,a.Q3)("",!0)])),_:1})]),(0,a.Lk)("div",fn,[n[27]||(n[27]=(0,a.Lk)("h4",null,"Console Output:",-1)),(0,a.Lk)("pre",wn,(0,S.v_)(l.getConsoleOutput()),1)])])]),(0,a.Lk)("div",Sn,[(0,a.Lk)("button",{onClick:n[0]||(n[0]=(...e)=>l.prevStep&&l.prevStep(...e)),disabled:s.currentStep<=1},"Vorheriger Schritt",8,zn),(0,a.Lk)("span",yn,"Schritt "+(0,S.v_)(s.currentStep)+" von "+(0,S.v_)(s.totalSteps),1),(0,a.Lk)("button",{onClick:n[1]||(n[1]=(...e)=>l.nextStep&&l.nextStep(...e)),disabled:s.currentStep>=s.totalSteps},"Nächster Schritt",8,An)]),(0,a.Lk)("div",Wn,[(0,a.Lk)("strong",null,"Schritt "+(0,S.v_)(s.currentStep)+":",1),(0,a.eW)(" "+(0,S.v_)(l.getStepDescription()),1)])]),n[38]||(n[38]=(0,a.Lk)("div",{class:"important-note"},[(0,a.Lk)("h4",null,"Wichtig zu wissen:"),(0,a.Lk)("ul",null,[(0,a.Lk)("li",null,[(0,a.Lk)("strong",null,"StackOverflowError:"),(0,a.eW)(" Bei zu vielen verschachtelten Methodenaufrufen (z.B. bei unbegrenzter Rekursion) kann der Call Stack voll werden, was zu einem StackOverflowError führt.")]),(0,a.Lk)("li",null,[(0,a.Lk)("strong",null,"Thread-spezifisch:"),(0,a.eW)(" Jeder Thread in Java hat seinen eigenen Call Stack. Daher können mehrere Threads unabhängig voneinander Methoden aufrufen.")]),(0,a.Lk)("li",null,[(0,a.Lk)("strong",null,"Stack-Größe:"),(0,a.eW)(" Die maximale Stack-Größe kann in der JVM konfiguriert werden (mit dem Parameter -Xss).")])])],-1)),n[39]||(n[39]=(0,a.Lk)("h3",null,"Bedeutung:",-1)),n[40]||(n[40]=(0,a.Lk)("p",null,"Der Call Stack ist essentiell für die Nachverfolgung von Methodenaufrufen und ermöglicht die Verschachtelung von Funktionsaufrufen. Bei rekursiven Aufrufen kann der Stack bei zu tiefer Rekursion überlaufen, was zu einem StackOverflowError führt.",-1))])])),_:1})}const xn={class:"theory-detail"},Mn={class:"theory-header"},Cn={class:"theory-inner-content"};function On(e,n,t,i,r,s){return(0,a.uX)(),(0,a.CE)("div",xn,[(0,a.Lk)("div",Mn,[(0,a.Lk)("button",{onClick:n[0]||(n[0]=(...e)=>s.goBack&&s.goBack(...e)),class:"back-button"},"← Zurück zur Übersicht"),(0,a.Lk)("h1",null,(0,S.v_)(t.title),1)]),(0,a.Lk)("div",Cn,[(0,a.RG)(e.$slots,"default")])])}var Pn={name:"TheoryLayout",props:{title:{type:String,required:!0}},methods:{goBack(){this.$router.push({name:"theory"})}}};const jn=(0,k.A)(Pn,[["render",On]]);var En=jn,Dn={name:"CallStackTheory",components:{TheoryLayout:En},data(){return{currentStep:1,totalSteps:15,consoleOutputs:["","","","Start im main","Start im main","Start im main","Start im main\nIn methodA","Start im main\nIn methodA","Start im main\nIn methodA","Start im main\nIn methodA\nIn methodB","Start im main\nIn methodA\nIn methodB","Start im main\nIn methodA\nIn methodB","Start im main\nIn methodA\nIn methodB\nZurück in methodA","Start im main\nIn methodA\nIn methodB\nZurück in methodA","Start im main\nIn methodA\nIn methodB\nZurück in methodA\nZurück in main","Start im main\nIn methodA\nIn methodB\nZurück in methodA\nZurück in main"],stepDescriptions:["","Programmbeginn - Die Klasse wird geladen.","Die main-Methode wird vorbereitet. Der main-Frame wird auf den Call Stack gelegt.","Die erste Ausgabe in main() wird ausgeführt.","Der Aufruf von methodA() wird vorbereitet.","Die methodA-Definition wird geladen. Der methodA-Frame wird auf den Call Stack gelegt.","Die erste Ausgabe in methodA() wird ausgeführt.","Der Aufruf von methodB() wird vorbereitet.","Die methodB-Definition wird geladen. Der methodB-Frame wird auf den Call Stack gelegt.","Die Ausgabe in methodB() wird ausgeführt.","methodB() ist beendet, der Frame wird vom Stack entfernt.","Die Ausführung kehrt zu methodA() zurück.","Die zweite Ausgabe in methodA() wird ausgeführt.","methodA() ist beendet, der Frame wird vom Stack entfernt.","Die Ausführung kehrt zu main() zurück und die zweite Ausgabe wird ausgeführt.","main() ist beendet, das Programm endet."]}},methods:{prevStep(){this.currentStep>1&&this.currentStep--},nextStep(){this.currentStep<this.totalSteps&&this.currentStep++},getConsoleOutput(){return this.consoleOutputs[Math.min(this.currentStep,this.consoleOutputs.length-1)]},getStepDescription(){return this.stepDescriptions[this.currentStep]}}};const In=(0,k.A)(Dn,[["render",Bn],["__scopeId","data-v-3374f7ad"]]);var Vn=In;function Hn(e,n,t,i,r,s){const l=(0,a.g2)("TheoryLayout");return(0,a.uX)(),(0,a.Wv)(l,{title:"Memory Stack"},{default:(0,a.k6)((()=>n[0]||(n[0]=[(0,a.Lk)("div",{class:"theory-content"},[(0,a.Lk)("h2",null,"Was ist der Memory Stack?"),(0,a.Lk)("p",null,"Der Memory Stack ist ein spezieller Speicherbereich in Java, der zur Laufzeit zugewiesen wird und primitive Datentypen sowie Referenzen auf Objekte speichert."),(0,a.Lk)("div",{class:"visual-container"},[(0,a.Lk)("div",{class:"visual-fallback"},[(0,a.Lk)("pre",null,"┌────────────────────────────┐\n│ Stack Frame: main()        │\n│                            │\n│ int x = 5                  │\n│ boolean flag = true        │\n│ Student s1 → [Heap: 0x1A2] │\n└────────────────────────────┘\n          ")])]),(0,a.Lk)("h3",null,"Inhalte des Memory Stack:"),(0,a.Lk)("div",{class:"content-grid"},[(0,a.Lk)("ul",null,[(0,a.Lk)("li",null,"Primitive Variablen (int, boolean, float, etc.)"),(0,a.Lk)("li",null,"Referenzvariablen (Zeiger auf Objekte im Heap)"),(0,a.Lk)("li",null,"Methodenparameter"),(0,a.Lk)("li",null,"Rückgabewerte"),(0,a.Lk)("li",null,"Temporäre Zwischenergebnisse von Berechnungen")])]),(0,a.Lk)("h3",null,"Eigenschaften des Memory Stacks:"),(0,a.Lk)("div",{class:"content-grid"},[(0,a.Lk)("div",{class:"content-item"},[(0,a.Lk)("h4",null,"Automatische Verwaltung"),(0,a.Lk)("p",null,"Variablen werden erstellt und gelöscht, wenn Methoden aufgerufen und beendet werden.")]),(0,a.Lk)("div",{class:"content-item"},[(0,a.Lk)("h4",null,"Lebensdauer"),(0,a.Lk)("p",null,"Nur während der Methodenausführung vorhanden, danach wird der Speicher freigegeben.")]),(0,a.Lk)("div",{class:"content-item"},[(0,a.Lk)("h4",null,"Geschwindigkeit"),(0,a.Lk)("p",null,"Schneller Zugriff durch das LIFO-Prinzip und vorhersehbare Allokation.")]),(0,a.Lk)("div",{class:"content-item"},[(0,a.Lk)("h4",null,"Begrenzte Größe"),(0,a.Lk)("p",null,"Festgelegt bei JVM-Start. Überschreitung führt zum StackOverflowError.")])]),(0,a.Lk)("div",{class:"example-box"},[(0,a.Lk)("h4",null,"Praktisches Beispiel:"),(0,a.Lk)("pre",{class:"code-example"},'public class StackExample {\n    public static void main(String[] args) {\n        int number = 42;\n        boolean isActive = true;\n        double pi = 3.14159;\n        String text = "Hallo Welt";\n        int[] numbers = {1, 2, 3, 4, 5};\n        int result = calculate(number);\n    }\n\n    public static int calculate(int input) {\n        int squared = input * input;\n        return squared;\n    }\n}'),(0,a.Lk)("div",{class:"example-explanation"},[(0,a.Lk)("p",null,[(0,a.Lk)("strong",null,"Stack-Status während der Ausführung:")]),(0,a.Lk)("pre",null,"┌────────────────────────────────┐\n│ Stack Frame: calculate()       │\n│ input = 42                     │\n│ squared = 1764                 │\n├────────────────────────────────┤\n│ Stack Frame: main()            │\n│ number = 42                    │\n│ isActive = true                │\n│ pi = 3.14159                   │\n│ text → [Heap: String-Objekt]   │\n│ numbers → [Heap: Array-Objekt] │\n│ result = ?                     │\n└────────────────────────────────┘\n          ")])]),(0,a.Lk)("div",{class:"flex-container"},[(0,a.Lk)("div",{class:"important-note"},[(0,a.Lk)("h4",null,"Wichtig zu wissen:"),(0,a.Lk)("ul",null,[(0,a.Lk)("li",null,[(0,a.Lk)("strong",null,"Primitive vs. Referenzen:"),(0,a.eW)(" Primitive Werte liegen direkt im Stack. Referenzen zeigen auf Heap-Objekte.")]),(0,a.Lk)("li",null,[(0,a.Lk)("strong",null,"Stack pro Thread:"),(0,a.eW)(" Jeder Thread hat seinen eigenen Stack.")]),(0,a.Lk)("li",null,[(0,a.Lk)("strong",null,"Kein Garbage Collection:"),(0,a.eW)(" Speicher wird automatisch freigegeben.")])])]),(0,a.Lk)("div",{class:"summary-section"},[(0,a.Lk)("h3",null,"Zusammenfassung:"),(0,a.Lk)("p",null,"Der Memory Stack ist zuständig für die Verwaltung von lokalen Variablen und Methodenaufrufen. Durch seine automatische Speicherverwaltung und hohe Geschwindigkeit ist er ein zentraler Bestandteil der JVM-Laufzeitumgebung.")])]),(0,a.Lk)("div",{class:"comparison-section"},[(0,a.Lk)("h3",null,"Stack vs. Heap im Überblick:"),(0,a.Lk)("div",{class:"table-container"},[(0,a.Lk)("table",{class:"comparison-table"},[(0,a.Lk)("thead",null,[(0,a.Lk)("tr",null,[(0,a.Lk)("th",null,"Eigenschaft"),(0,a.Lk)("th",null,"Stack"),(0,a.Lk)("th",null,"Heap")])]),(0,a.Lk)("tbody",null,[(0,a.Lk)("tr",null,[(0,a.Lk)("td",null,[(0,a.Lk)("strong",null,"Gespeicherte Daten")]),(0,a.Lk)("td",null,"Primitive Typen, Referenzen"),(0,a.Lk)("td",null,"Objekte, Arrays, Strings")]),(0,a.Lk)("tr",null,[(0,a.Lk)("td",null,[(0,a.Lk)("strong",null,"Lebensdauer")]),(0,a.Lk)("td",null,"Während Methodenausführung"),(0,a.Lk)("td",null,"Bis keine Referenzen mehr existieren")]),(0,a.Lk)("tr",null,[(0,a.Lk)("td",null,[(0,a.Lk)("strong",null,"Zugriff")]),(0,a.Lk)("td",null,"Jeder hat zugriff auf alles im Heap"),(0,a.Lk)("td",null,"Zugriff nur auf eigenen Stack-Frame (Funktionsbereich)")]),(0,a.Lk)("tr",null,[(0,a.Lk)("td",null,[(0,a.Lk)("strong",null,"Speicherfreigabe")]),(0,a.Lk)("td",null,"Automatisch (LIFO)"),(0,a.Lk)("td",null,"Garbage Collector")]),(0,a.Lk)("tr",null,[(0,a.Lk)("td",null,[(0,a.Lk)("strong",null,"Grösse")]),(0,a.Lk)("td",null,"Fest vorgegeben"),(0,a.Lk)("td",null,"Dynamisch (kann wachsen)")]),(0,a.Lk)("tr",null,[(0,a.Lk)("td",null,[(0,a.Lk)("strong",null,"Zugriffsgeschwindigkeit")]),(0,a.Lk)("td",null,"Sehr schnell, ist kleiner"),(0,a.Lk)("td",null,"Langsamer als Stack, ist grösser, muss durchsucht werden")]),(0,a.Lk)("tr",null,[(0,a.Lk)("td",null,[(0,a.Lk)("strong",null,"Fehler bei Überlauf")]),(0,a.Lk)("td",null,"StackOverflowError"),(0,a.Lk)("td",null,"OutOfMemoryError")])])])])])],-1)]))),_:1})}var Fn={name:"MemoryStackTheory",components:{TheoryLayout:En},mounted(){}};const Jn=(0,k.A)(Fn,[["render",Hn],["__scopeId","data-v-78f531b8"]]);var _n=Jn;function qn(e,n,t,i,r,s){const l=(0,a.g2)("TheoryLayout");return(0,a.uX)(),(0,a.Wv)(l,{title:"Memory Heap"},{default:(0,a.k6)((()=>n[0]||(n[0]=[(0,a.Lk)("div",{class:"theory-content"},[(0,a.Lk)("h2",null,"Was ist der Memory Heap?"),(0,a.Lk)("p",null,"Der Memory Heap ist ein dynamischer Speicherbereich, der von JVM verwaltet wird. In ihm werden Arrays und Objekte von Klassen zur Laufzeit dynamisch erstellt und verwaltet."),(0,a.Lk)("p",null,"Anders als der Stack, der nur temporäre Werte speichert, speichert der Heap die Daten langfristig."),(0,a.Lk)("div",{class:"analogy-box"},[(0,a.Lk)("h3",null,"Alltagsbeispiel"),(0,a.Lk)("p",null,"Stell dir den Heap wie eine grosse Bücherei vor, und den Stack wie deinen Schreibtisch:"),(0,a.Lk)("ul",null,[(0,a.Lk)("li",null,[(0,a.Lk)("strong",null,"Die Bücherei (Heap):"),(0,a.eW)(" Ein riesiger, gemeinsamer Raum, in dem alle Bücher (Objekte) aufbewahrt werden. Wenn die Bücherei ein neues Buch kauf (ein Objekt erstellst), wird es dort in den Regalen eingeordnet. Die Bücher bleiben so lange dort, bis sie niemand mehr braucht (keine Referenz mehr).")]),(0,a.Lk)("li",null,[(0,a.Lk)("strong",null,"Dein Schreibtisch (Stack):"),(0,a.eW)(" Ein kleiner, persönlicher Bereich, auf dem du schnell Notizen (primitive Variablen) machst oder Liste von Büchern (Referenzen) ablegst, die du von der Bücherei ausleihen willst. Verlässt du den Raum (Methode endet), wird dein Schreibtisch komplett abgeräumt, du siehst ihn nicht mehr.")])]),(0,a.Lk)("p",null,"Da der Stack viel kleiner ist, als der Heap ist im Stack jeweils nur eine Referenz auf die Speicheradresse im Heap hinterlegt, wo sich das Objekt befindet.")]),(0,a.Lk)("div",{class:"object-creation-section"},[(0,a.Lk)("h3",null,"Objekte im Heap: Neue Bücher in der Bücherei"),(0,a.Lk)("p",null,[(0,a.eW)("Der Heap speichert alle Objekte, die mit "),(0,a.Lk)("code",null,"new"),(0,a.eW)(" erstellt werden, sowie ihre Instanzvariablen.")]),(0,a.Lk)("div",{class:"two-column-layout"},[(0,a.Lk)("div",{class:"column"},[(0,a.Lk)("pre",{class:"code-example"},"class Buch {\n    int seitenzahl;\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Buch meinBuch = new Buch();  // Speicherzuweisung im Heap\n        meinBuch.seitenzahl = 350; // Referenz auf das Buch im Heap\n    }\n}")]),(0,a.Lk)("div",{class:"column"},[(0,a.Lk)("div",{class:"explanation-box"},[(0,a.Lk)("ul",null,[(0,a.Lk)("li",null,[(0,a.eW)("Mit "),(0,a.Lk)("code",null,"new"),(0,a.eW)(" wird ein neues "),(0,a.Lk)("strong",null,"Buch-Objekt"),(0,a.eW)(" erstellt. Das ist wie ein neues Buch, das in der Bücherei (Heap) eingeordnet wird")]),(0,a.Lk)("li",null,[(0,a.eW)("Die Variable "),(0,a.Lk)("strong",null,"meinBuch"),(0,a.eW)(" liegt im Stack und enthält eine Referenz auf das Buch im Heap. Das ist wie ein Ausleihzettel (im Stack), der auf das Buch im Regal zeigt.")]),(0,a.Lk)("li",null,[(0,a.eW)("Die Eigenschaft "),(0,a.Lk)("strong",null,"seitenzahl"),(0,a.eW)(" ist eine Instanzvariable des Objekts. Das ist wie die Anzahl der Seiten im Buch. Der Wert "),(0,a.Lk)("strong",null,"350"),(0,a.eW)(" wird direkt im Buch gespeichert, man sieht erst wie viele Seitenzahlen das Buch hat wenn man es öffnet.")])])])])])]),(0,a.Lk)("div",{class:"two-column-layout align-items-start"},[(0,a.Lk)("div",{class:"column"},[(0,a.Lk)("div",{class:"content-box"},[(0,a.Lk)("h3",null,"Inhalte des Heaps:"),(0,a.Lk)("ul",null,[(0,a.Lk)("li",null,[(0,a.Lk)("strong",null,"Objekte:"),(0,a.eW)(" Instanzen von Klassen (neue Objekte mit "),(0,a.Lk)("code",null,"new"),(0,a.eW)(" erstellt)")]),(0,a.Lk)("li",null,[(0,a.Lk)("strong",null,"Arrays:"),(0,a.eW)(" Auch wenn sie primitive Werte enthalten, ist das Array-Objekt selbst im Heap")]),(0,a.Lk)("li",null,[(0,a.Lk)("strong",null,"Strings:"),(0,a.eW)(" String-Objekte werden im Heap gespeichert (mit String-Pool-Optimierungen)")]),(0,a.Lk)("li",null,[(0,a.Lk)("strong",null,"Komplexe Datenstrukturen:"),(0,a.eW)(" Listen, Maps und alle anderen Kollektionen")]),(0,a.Lk)("li",null,[(0,a.Lk)("strong",null,"Klasseninstanzen"),(0,a.eW)(" mit ihren Instanzvariablen")]),(0,a.Lk)("li",null,[(0,a.Lk)("strong",null,"Instanzvariablen:"),(0,a.eW)(" Die Felder/Attribute eines Objekts")])])])]),(0,a.Lk)("div",{class:"column"},[(0,a.Lk)("div",{class:"visual-container"},[(0,a.Lk)("div",{class:"visual-fallback"},[(0,a.Lk)("pre",null,'┌──────────────────────────────┐\n│            HEAP              │\n│                              │\n│  ┌───────────┐  ┌──────────┐ │\n│  │ String    │  │ Person   │ │\n│  │ "Hallo"   │  │name="Max"│ │\n│  └───────────┘  │alter=25  │ │\n│                 └──────────┘ │\n│  ┌───────────┐               │\n│  │ int[]     │  ┌──────────┐ │\n│  │ [3,1,4,2] │  │ ArrayList│ │\n│  └───────────┘  └──────────┘ │\n│                              │\n└──────────────────────────────┘\n          ')])])])]),(0,a.Lk)("div",{class:"example-box"},[(0,a.Lk)("h4",null,"Praktisches Bücherei-Beispiel:"),(0,a.Lk)("p",null,"Denk an ein Bibliotheks-Management-System. Hier sehen wir, wie verschiedene Informationen im Heap gespeichert werden:"),(0,a.Lk)("pre",{class:"code-example"},'public class BibliothekenBeispiel {\n    public static void main(String[] args) {\n        // Ein Buch-Objekt wird im Heap erstellt\n        Buch buch1 = new Buch("Java für Anfänger", "Programmierung");\n        \n        // Ein weiteres Buch im Heap\n        Buch buch2 = new Buch("Algorithmen verstehen", "Informatik");\n        \n        // Array mit Bewertungen - das Array selbst ist ein Objekt im Heap\n        double[] bewertungen = {3.8, 4.2, 4.5, 5.0};\n        \n        // Die ArrayList ist ein Objekt im Heap\n        ArrayList<String> ausleiher = new ArrayList<>();\n        ausleiher.add("Max Mustermann"); // Jeder String ist auch ein Objekt im Heap\n        ausleiher.add("Lisa Schmidt");\n        \n        // Bibliothek-Objekt mit Buch-Referenzen\n        Bibliothek bibliothek = new Bibliothek("Stadtbibliothek");\n        bibliothek.addBuch(buch1);\n        bibliothek.addBuch(buch2);\n        \n        // Methode beenden: buch1, buch2, bewertungen, ausleiher und bibliothek \n        // bleiben im Heap, solange Referenzen bestehen\n    }\n}\n\nclass Buch {\n    private String titel;    // Referenz zu einem String im Heap\n    private String kategorie; // Referenz zu einem String im Heap\n    \n    public Buch(String titel, String kategorie) {\n        this.titel = titel;\n        this.kategorie = kategorie;\n    }\n}\n\nclass Bibliothek {\n    private String name;\n    private List<Buch> bücher = new ArrayList<>();\n    \n    public Bibliothek(String name) {\n        this.name = name;\n    }\n    \n    public void addBuch(Buch buch) {\n        bücher.add(buch);\n    }\n}'),(0,a.Lk)("div",{class:"heap-visualization"},[(0,a.Lk)("p",null,[(0,a.Lk)("strong",null,"So sieht der Heap-Speicher (unsere Bücherei) dafür aus:")]),(0,a.Lk)("pre",null,'BÜCHEREI (HEAP):\n┌──────────────────────────────────────────────────────────┐\n│                                                          │\n│  ┌──────────┐      ┌───────────────────┐ ┌───────────┐   │\n│  │ Buch     │      │ String            │ │ String    │   │\n│  │ titel  ──┼─────▶│ "Java für         │ │ "Program- │   │\n│  │ kateg. ──┼─────▶│  Anfänger"        │ │  mierung" │   │\n│  └──────────┘      └───────────────────┘ └───────────┘   │\n│                                                          │\n│  ┌──────────┐      ┌───────────────────┐ ┌───────────┐   │\n│  │ Buch     │      │ String            │ │ String    │   │\n│  │ titel  ──┼─────▶│ "Algorithmen      │ │ "Informatik"  │\n│  │ kateg. ──┼─────▶│  verstehen"       │ │           │   │\n│  └──────────┘      └───────────────────┘ └───────────┘   │\n│                                                          │\n│  ┌──────────┐                                            │\n│  │ double[] │                                            │\n│  │ [3.8,    │                                            │\n│  │  4.2,    │                                            │\n│  │  4.5,    │                                            │\n│  │  5.0]    │                                            │\n│  └──────────┘                                            │\n│                                                          │\n│  ┌────────────┐    ┌────────────────────┐ ┌───────────┐  │\n│  │ ArrayList  │    │ String             │ │ String    │  │\n│  │ size=2     │    | "Max Mustermann"   │ │ "Lisa     │  │\n│  │ elements───┼───▶│                    │ │  Schmidt" │  │\n│  └────────────┘    └────────────────────┘ └───────────┘  │\n│                                                          │\n│  ┌────────────┐    ┌─────────────────────┐               │\n│  │ Bibliothek │    │ String              │               │\n│  │ name    ───┼───▶│ "Stadtbibliothek"   │               │\n│  │ bücher     │    └─────────────────────┘               │\n│  │ (Liste mit │                                          │\n│  │ Referenzen)│                                          │\n│  └────────────┘                                          │\n└──────────────────────────────────────────────────────────┘\n          ')]),(0,a.Lk)("div",{class:"explanation-box"},[(0,a.Lk)("ul",null,[(0,a.Lk)("li",null,[(0,a.Lk)("p",null,[(0,a.eW)("Die mit "),(0,a.Lk)("code",null,"new"),(0,a.eW)(" erstellten "),(0,a.Lk)("strong",null,"Buch-Objekte"),(0,a.eW)(),(0,a.Lk)("code",null,"buch1"),(0,a.eW)(" und "),(0,a.Lk)("code",null,"buch2"),(0,a.eW)(" sind eigenständige Objekte im Heap-Speicher.")]),(0,a.Lk)("p",null,"Jedes dieser Objekte besitzt Instanzvariablen, die als Referenzen auf die zugehörigen String-Objekte im Heap verweisen."),(0,a.Lk)("p",null,"Zum Beispiel:"),(0,a.Lk)("p",null,[(0,a.eW)("Das Buch-Objekt "),(0,a.Lk)("code",null,"buch1"),(0,a.eW)(" enthält eine Referenz auf den Titel "),(0,a.Lk)("strong",null,'"Java für Anfänger"'),(0,a.eW)(" sowie auf die Kategorie "),(0,a.Lk)("strong",null,'"Programmierung"'),(0,a.eW)(".")]),(0,a.Lk)("p",null,[(0,a.eW)("Das Buch-Objekt "),(0,a.Lk)("code",null,"buch2"),(0,a.eW)(" verweist entsprechend auf "),(0,a.Lk)("strong",null,'"Algorithmen verstehen"'),(0,a.eW)(" und "),(0,a.Lk)("strong",null,'"Informatik"'),(0,a.eW)(".")]),(0,a.Lk)("p",null,"Diese Buch-Objekte kann man sich wie Bücher in einer Bibliothek vorstellen:"),(0,a.Lk)("p",null,"Sie werden ins Regal gestellt (Heap), wo sie physisch vorhanden sind."),(0,a.Lk)("p",null,"Die Ausleihzettel (Referenzen) liegen im Verwaltungssystem (Stack), sodass man jederzeit auf die Bücher zugreifen kann.")]),(0,a.Lk)("li",null,[(0,a.Lk)("p",null,[(0,a.eW)("Die mit "),(0,a.Lk)("code",null,"new"),(0,a.eW)(" erzeugte "),(0,a.Lk)("strong",null,"ArrayList"),(0,a.eW)(),(0,a.Lk)("code",null,"ausleiher"),(0,a.eW)(" ist ebenfalls ein Objekt im Heap.")]),(0,a.Lk)("p",null,"Sie speichert Referenzen auf String-Objekte, die die Namen der Personen enthalten, die Bücher ausgeliehen haben."),(0,a.Lk)("p",null,[(0,a.eW)("In diesem Fall zeigt die Liste auf die Strings "),(0,a.Lk)("strong",null,'"Max Mustermann"'),(0,a.eW)(" und "),(0,a.Lk)("strong",null,'"Lisa Schmidt"'),(0,a.eW)(", die ebenfalls im Heap liegen.")]),(0,a.Lk)("p",null,"Dies entspricht einer Liste der Leser in der Bibliothek, die registriert sind und Bücher ausgeliehen haben.")]),(0,a.Lk)("li",null,[(0,a.Lk)("p",null,[(0,a.eW)("Das "),(0,a.Lk)("strong",null,"Array"),(0,a.eW)(),(0,a.Lk)("code",null,"bewertungen"),(0,a.eW)(" ist ein weiteres Objekt im Heap, das Bewertungen der Bücher speichert.")]),(0,a.Lk)("p",null,"Es enthält double-Werte wie [3.8, 4.2, 4.5, 5.0]."),(0,a.Lk)("p",null,"Da Arrays in Java ebenfalls Objekte im Heap sind, wird das Array als Ganzes dort abgelegt."),(0,a.Lk)("p",null,"Dies kann man sich vorstellen wie einen Bewertungsbogen, der die Lesermeinungen über Bücher sammelt.")]),(0,a.Lk)("li",null,[(0,a.Lk)("p",null,[(0,a.eW)("Das "),(0,a.Lk)("strong",null,"Bibliothek-Objekt"),(0,a.eW)(),(0,a.Lk)("code",null,"bibliothek"),(0,a.eW)(" wird ebenfalls mit "),(0,a.Lk)("code",null,"new"),(0,a.eW)(" erstellt und im Heap gespeichert.")]),(0,a.Lk)("p",null,'Es speichert den Namen "Stadtbibliothek" als Referenz auf ein String-Objekt im Heap.'),(0,a.Lk)("p",null,[(0,a.eW)("Zusätzlich enthält es eine Liste von Buch-Referenzen, die auf "),(0,a.Lk)("code",null,"buch1"),(0,a.eW)(" und "),(0,a.Lk)("code",null,"buch2"),(0,a.eW)(" zeigen.")]),(0,a.Lk)("p",null,"Diese Klasse ist vergleichbar mit dem Verwaltungssystem der Bibliothek, das den Bestand der Bücher organisiert.")])]),(0,a.Lk)("h4",null,"Zusammenfassung (Metapher)"),(0,a.Lk)("ul",null,[(0,a.Lk)("li",null,[(0,a.eW)("Buch-Objekte ("),(0,a.Lk)("code",null,"buch1"),(0,a.eW)(", "),(0,a.Lk)("code",null,"buch2"),(0,a.eW)(") sind echte Bücher im Regal der Bibliothek (Heap).")]),(0,a.Lk)("li",null,"Titel und Kategorien sind Beschriftungen und Genres der Bücher."),(0,a.Lk)("li",null,"Array für Bewertungen ist ein Bewertungsbogen, der Lesermeinungen speichert."),(0,a.Lk)("li",null,"ArrayList der Ausleiher ist eine Liste der Leser, die Bücher ausgeliehen haben."),(0,a.Lk)("li",null,"Bibliothek-Objekt entspricht dem Verwaltungssystem, das alle Bücher katalogisiert."),(0,a.Lk)("li",null,[(0,a.eW)("Referenzvariablen im Stack (z. B. "),(0,a.Lk)("code",null,"buch1"),(0,a.eW)(", "),(0,a.Lk)("code",null,"buch2"),(0,a.eW)(") sind Ausleihzettel, die zeigen, wo die Bücher im Regal stehen.")])]),(0,a.Lk)("ul",null,[(0,a.Lk)("li",null,[(0,a.Lk)("p",null,[(0,a.eW)("Die "),(0,a.Lk)("strong",null,"Buch-Objekte"),(0,a.eW)(' "buch1", "buch2" die mit '),(0,a.Lk)("code",null,"new"),(0,a.eW)(" erstellt wurden, sind eigene Objekte im Heap.")]),(0,a.Lk)("p",null,"Jedes dieser Objekte enthält die Instanzvariablen mit der Referenz auf den entsprechenden String."),(0,a.Lk)("p",null,'Beispielsweise enthält das Buch-Objekt "buch1" die Referenz auf den String "Java für Anfänger" und die Kategorie "Programmierung".'),(0,a.Lk)("p",null,"Es sind wie Bücher, die in ein Regal der Bücherei gestellt werden, damit man sie ansehen kann.")]),(0,a.Lk)("li",null,[(0,a.eW)("Die "),(0,a.Lk)("strong",null,"Bibliothek-Klasse"),(0,a.eW)(" ist wie das Verwaltungssystem der Bücherei")]),(0,a.Lk)("li",null,[(0,a.eW)("Die "),(0,a.Lk)("strong",null,"Titel und Kategorien"),(0,a.eW)(" sind wie Beschriftungen und Genres der Bücher")]),(0,a.Lk)("li",null,[(0,a.eW)("Das "),(0,a.Lk)("strong",null,"Bewertungs-Array"),(0,a.eW)(" ist wie ein Bewertungsbogen für Bücher")]),(0,a.Lk)("li",null,[(0,a.eW)("Die "),(0,a.Lk)("strong",null,"ArrayList"),(0,a.eW)(" für Ausleiher ist wie eine Liste der Leser, die Bücher ausgeliehen haben")])]),(0,a.Lk)("p",null,[(0,a.eW)("Wenn die "),(0,a.Lk)("code",null,"main"),(0,a.eW)('-Methode endet, bleiben alle Bücher und Informationen im Heap (der Bücherei), solange noch Referenzen darauf existieren. Erst wenn keine "Ausleihzettel" (Referenzen) mehr vorhanden sind, kann der Bibliothekar (Garbage Collector) die Bücher aussortieren.')])])]),(0,a.Lk)("h3",null,"String-Pool: Eine Besonderheit im Heap"),(0,a.Lk)("div",{class:"two-column-layout"},[(0,a.Lk)("div",{class:"column"},[(0,a.Lk)("div",{class:"string-pool"},[(0,a.Lk)("p",null,"Java optimiert die Speicherung von Strings durch einen speziellen Bereich im Heap, den String-Pool:"),(0,a.Lk)("p",null,"Stell dir den String-Pool wie ein besonderes Bücherregal nur für häufig verwendete Bücher vor:"),(0,a.Lk)("pre",{class:"code-example"},'String s1 = "Java";       // Wird im String-Pool abgelegt\nString s2 = "Java";       // Greift auf das gleiche Buch im Pool zu\nString s3 = new String("Java");  // Erstellt eine neue Kopie des Buches ausserhalb des Pools\n\nSystem.out.println(s1 == s2);     // true - beide haben denselben Ausweis\nSystem.out.println(s1 == s3);     // false - unterschiedliche Ausweise\nSystem.out.println(s1.equals(s3)); // true - gleicher Inhalt, aber verschiedene Exemplare'),(0,a.Lk)("p",null,"Mit dem befehl new String, kann im Heap ein String ausserhalb des String-Pools erstellt werden. Das ist, als würden zwei Studenten (s1 und s2) das gleiche Bibliotheksbuch ausleihen, während ein dritter (s3) eine private Kopie kauft.")])]),(0,a.Lk)("div",{class:"column"},[(0,a.Lk)("div",{class:"visual-container"},[(0,a.Lk)("div",{class:"visual-fallback"},[(0,a.Lk)("pre",null,'HEAP:\n┌─────────────────────────────────┐\n│                                 │\n│ ┌───────────────────┐           │\n│ │    String-Pool    │           │\n│ │  ┌─────────────┐  │           │\n│ │  │   "Java"    │◀─┼──── s1    │\n│ │  └─────────────┘  │      s2   │\n│ │                   │           │\n│ └───────────────────┘           │\n│                                 │\n│                                 │\n│ ┌─────────────────┐             │\n│ │     "Java"      │◀─────── s3  │\n│ └─────────────────┘             │\n│                                 │\n└─────────────────────────────────┘\n              ')])])])]),(0,a.Lk)("div",{class:"heap-stack-connection"},[(0,a.Lk)("h3",null,"Wie sind Heap und Stack verknüpft?"),(0,a.Lk)("div",{class:"explanation-box"},[(0,a.Lk)("ul",null,[(0,a.Lk)("li",null,[(0,a.Lk)("strong",null,"Lokale Variablen"),(0,a.eW)(" (primitive Typen & Referenzen) sind wie Notizen auf deinem persönlichen Zettel (Stack)")]),(0,a.Lk)("li",null,[(0,a.Lk)("strong",null,"Objekte und Instanzvariablen"),(0,a.eW)(" sind wie die Bücher selbst und ihre Inhalte (im Heap)")]),(0,a.Lk)("li",null,[(0,a.Lk)("strong",null,"Methodenende:"),(0,a.eW)(" Wenn du den Leseraum verlässt (Methode endet), wird dein Notizzettel weggeworfen (Stack-Frame gelöscht), aber die Bücher bleiben in den Regalen (Heap), solange noch jemand einen Ausleihzettel dafür hat")])]),(0,a.Lk)("p",null,"Das bedeutet: Solange ein Buch (Objekt oder Array) noch von irgendjemandem gelesen wird (eine Referenz hat), bleibt es in der Bücherei (Heap). Erst wenn niemand mehr darauf verweist, kann es aussortiert werden.")])]),(0,a.Lk)("div",{class:"gc-example"},[(0,a.Lk)("h4",null,"Speicherfreigabe durch den Bibliothekar (Garbage Collector)"),(0,a.Lk)("p",null,'Beim Heap wird der Speicher nicht mehr verwendeter Objekte automatisch vom Garbage Collector freigegeben. Das bedeutet, wenn im Code keine Referenz mehr auf ein Objekt verweist, wird es als "unreachable" (unerreichbar) markiert und entfernt.'),(0,a.Lk)("div",{class:"two-column-layout"},[(0,a.Lk)("div",{class:"column"},[(0,a.Lk)("pre",{class:"code-example"},'public class GCBeispiel {\n    public static void main(String[] args) {\n        // Buch wird erstellt und im Heap abgelegt\n        Buch javaBuch = new Buch("Java Grundlagen");\n        \n        System.out.println(javaBuch.titel);\n        \n        // Referenz wird überschrieben\n        javaBuch = new Buch("Java Fortgeschritten");\n        \n        // Das erste Buch hat keine Referenz mehr\n        // und ist bereit für den Garbage Collector\n    }\n}\n\nclass Buch {\n    String titel;\n    \n    public Buch(String titel) {\n        this.titel = titel;\n    }\n}')]),(0,a.Lk)("div",{class:"column"},[(0,a.Lk)("div",{class:"visual-container"},[(0,a.Lk)("div",{class:"visual-fallback"},[(0,a.Lk)("pre",null,'Vor der Neuzuweisung:      Nach der Neuzuweisung:\n┌──────────────┐           ┌───────────────────┐\n│ javaBuch     │           │ javaBuch          │\n└──────┬───────┘           └─────────┬─────────┘\n       │                             │\n       ▼                             ▼\n┌──────────────┐           ┌───────────────────┐\n│ Buch         │           │ Buch              │\n│"Java         │           │"Java              │\n│ Grundlagen"  │           │ Fortgeschritten"  │\n└──────────────┘           └───────────────────┘\n                          \n                           ┌───────────────────┐\n                           │ Buch              │\n                           │"Java Grundlagen"  │\n                           │(keine Referenz)   │\n                           │→ GC bereit        │\n                           └───────────────────┘')])])])])]),(0,a.Lk)("div",{class:"gc-section"},[(0,a.Lk)("h3",null,"Heap-Speicherverwaltung und Garbage Collection:"),(0,a.Lk)("p",null,"Anders als der Stack wird der Heap nicht automatisch bei Methodenenden aufgeräumt. Java nutzt die Garbage Collection, einen automatischen Prozess, der nicht mehr benötigten Speicher im Heap freigibt."),(0,a.Lk)("div",{class:"two-column-layout align-items-start"},[(0,a.Lk)("div",{class:"column"},[(0,a.Lk)("div",{class:"gc-explanation"},[(0,a.Lk)("h4",null,"So funktioniert Garbage Collection - in Alltagsbegriffen:"),(0,a.Lk)("p",null,"Stell dir vor, der Heap ist eine große Bibliothek und der Garbage Collector ein fleißiger Bibliothekar:"),(0,a.Lk)("ol",null,[(0,a.Lk)("li",null,[(0,a.Lk)("strong",null,"Identifikation:"),(0,a.eW)(" Der Bibliothekar prüft, welche Bücher (Objekte) keine Ausweise (Referenzen) mehr haben, die auf sie zeigen.")]),(0,a.Lk)("li",null,[(0,a.Lk)("strong",null,"Markieren:"),(0,a.eW)(" Bücher, die noch von jemandem ausgeliehen werden könnten (erreichbare Objekte), bekommen ein Lesezeichen.")]),(0,a.Lk)("li",null,[(0,a.Lk)("strong",null,"Aussortieren/Löschen:"),(0,a.eW)(" Bücher ohne Lesezeichen (nicht erreichbare Objekte) werden aus den Regalen entfernt.")]),(0,a.Lk)("li",null,[(0,a.Lk)("strong",null,"Neu ordnen:"),(0,a.eW)(" Die Regale werden neu geordnet, um Platz zu schaffen (Speicherkomprimierung).")])]),(0,a.Lk)("p",null,"Dieser Prozess geschieht automatisch und in regelmäßigen Abständen, aber kann manchmal zu kurzen Pausen in der Programmausführung führen - ähnlich wie wenn die Bibliothek kurz schließt, um aufzuräumen.")])]),(0,a.Lk)("div",{class:"column"},[(0,a.Lk)("div",{class:"visual-container gc-visual"},[(0,a.Lk)("div",{class:"visual-fallback"},[(0,a.Lk)("pre",null,"Vor GC:              Nach GC:\n┌────────┐           ┌────────┐\n│ Obj A  │◀───┐      │ Obj A  │◀───┐\n└────────┘    │      └────────┘     │\n              │                     │\n┌────────┐    │      ┌────────┐     │\n│ Obj B  │    │      │ Obj C  │     │\n└────────┘    │      └────────┘     │\n              │                     │\n┌────────┐    │                     │\n│ Obj C  │◀───┼─────Referenz        │\n└────────┘    │                     │\n              │                     │\n┌────────┐    │      (Obj B wurde   │\n│ Obj D  │    │      freigegeben,   │\n└────────┘    │      Obj D auch)    │\n              │                     │\nReferenzen────┘      Referenzen─────┘\n                ")])])])])]),(0,a.Lk)("div",{class:"memory-leaks-detail"},[(0,a.Lk)("h3",null,"Memory Leaks"),(0,a.Lk)("p",null,"Wenn Objekte unnötig referenziert bleiben und somit nicht gelöscht werden können, obwohl sie nicht mehr gebraucht werden, spricht man von einem Memory Leak (Speicherleck)."),(0,a.Lk)("div",{class:"example-box"},[(0,a.Lk)("h4",null,"Alltagsbeispiel"),(0,a.Lk)("p",null,"Stell dir vor, ein Student hat einen Ausleihzettel für ein Fachbuch, das er längst nicht mehr liest. Er hat den Zettel in einer Schublade vergessen und verlässt die Universität. Das Buch bleibt in der Bücherei und belegt wertvollen Platz, obwohl es niemand mehr braucht - aber der Bibliothekar kann es nicht entfernen, weil formal noch ein Ausleihzettel existiert.")])]),(0,a.Lk)("div",{class:"important-note"},[(0,a.Lk)("h4",null,"Probleme:"),(0,a.Lk)("ul",null,[(0,a.Lk)("li",null,[(0,a.Lk)("strong",null,"OutOfMemoryError:"),(0,a.eW)(" Wenn der Heap voll ist und die Garbage Collection nicht genug Speicher freigeben kann, wird ein OutOfMemoryError ausgelöst - wie wenn deine Bücherei keinen Platz mehr für neue Bücher hat.")]),(0,a.Lk)("li",null,[(0,a.Lk)("strong",null,"Referenzen sind der Schlüssel:"),(0,a.eW)(" Objekte werden nicht automatisch gelöscht, wenn sie nicht mehr verwendet werden - sie müssen für die Garbage Collection nicht mehr referenziert sein. Wie ein Buch, das niemand mehr ausleihen will.")]),(0,a.Lk)("li",null,[(0,a.Lk)("strong",null,"Speicher-Leaks:"),(0,a.eW)(" Wenn Objekte unnötig referenziert bleiben, können Speicherlecks entstehen, auch in Java. Das ist wie Bücher, die niemand mehr liest, aber trotzdem nicht aussortiert werden können, weil jemand sie theoretisch noch lesen könnte.")])])]),(0,a.Lk)("div",{class:"summary-section"},[(0,a.Lk)("h3",null,"Zusammenfassung:"),(0,a.Lk)("p",null,'Der Heap ist wie eine grosse Bibliothek für alle Objekte in einem Java-Programm. Im Gegensatz zum Stack, der sich automatisch leert, benötigt der Heap einen "Hausmeister" (den Garbage Collector), der regelmässig aufräumt.'),(0,a.Lk)("ul",null,[(0,a.Lk)("li",null,[(0,a.eW)("Mit "),(0,a.Lk)("code",null,"new"),(0,a.eW)(" wird ein neues Objekt im Heap erstellt")]),(0,a.Lk)("li",null,"Referenzen zeigen auf Objekte - sie sind nicht die Objekte selbst"),(0,a.Lk)("li",null,"Speicherplatz kann erst freigegeben werden, wenn keine Referenz mehr auf das Objekt zeigt")])])],-1)]))),_:1})}var Rn={name:"MemoryHeapTheory",components:{TheoryLayout:En},mounted(){}};const Kn=(0,k.A)(Rn,[["render",qn],["__scopeId","data-v-73605166"]]);var Tn=Kn;function Gn(e,n,t,i,r,s){const l=(0,a.g2)("TheoryLayout");return(0,a.uX)(),(0,a.Wv)(l,{title:"Method Area"},{default:(0,a.k6)((()=>n[0]||(n[0]=[(0,a.Lk)("div",{class:"theory-content"},[(0,a.Lk)("h2",null,"Was ist die Method Area?"),(0,a.Lk)("p",null,"Die Method Area (auch als Metadatenbereich bekannt) ist ein Teil des JVM-Speichers, der Klasseninformationen und statische Daten speichert."),(0,a.Lk)("div",{class:"visual-container"},[(0,a.Lk)("div",{class:"visual-fallback"},[(0,a.Lk)("pre",null,"┌─────────────────────────────────────┐\n│           METHOD AREA               │\n│                                     │\n│  ┌─────────────────────────────┐    │\n│  │ Klasse: Student             │    │\n│  │ - Statische Felder          │    │\n│  │ - Methodencode              │    │\n│  │ - Konstantenpool            │    │\n│  └─────────────────────────────┘    │\n│                                     │\n│  ┌─────────────────────────────┐    │\n│  │ Klasse: Calculator          │    │\n│  │ - Statische Felder          │    │\n│  │ - Methodencode              │    │\n│  │ - Konstantenpool            │    │\n│  └─────────────────────────────┘    │\n│                                     │\n│  ┌─────────────────────────────┐    │\n│  │ Klasse: Course              │    │\n│  │ - Statische Felder          │    │\n│  │ - Methodencode              │    │\n│  │ - Konstantenpool            │    │\n│  └─────────────────────────────┘    │\n│                                     │\n└─────────────────────────────────────┘\n          ")])]),(0,a.Lk)("h3",null,"Inhalte der Method Area:"),(0,a.Lk)("div",{class:"content-grid"},[(0,a.Lk)("div",{class:"content-item"},[(0,a.Lk)("h4",null,"1. Klassenmetadaten"),(0,a.Lk)("ul",null,[(0,a.Lk)("li",null,"Vollständiger Klassenname und Paketinformation"),(0,a.Lk)("li",null,"Vererbungshierarchie (Superklassen, implementierte Interfaces)"),(0,a.Lk)("li",null,"Informationen über Konstruktoren und Methoden"),(0,a.Lk)("li",null,"Typinformationen und Zugriffsbeschränkungen"),(0,a.Lk)("li",null,"Annotations und andere Metadaten")])]),(0,a.Lk)("div",{class:"content-item"},[(0,a.Lk)("h4",null,"2. Statische Variablen"),(0,a.Lk)("ul",null,[(0,a.Lk)("li",null,[(0,a.eW)("Alle mit "),(0,a.Lk)("code",null,"static"),(0,a.eW)(" deklarierten Felder")]),(0,a.Lk)("li",null,[(0,a.eW)("Klassenweite Konstanten ("),(0,a.Lk)("code",null,"static final"),(0,a.eW)(")")]),(0,a.Lk)("li",null,"Datenwerte, die für alle Instanzen gleich sind"),(0,a.Lk)("li",null,[(0,a.eW)("Beispiel: "),(0,a.Lk)("code",null,"Math.PI"),(0,a.eW)(", "),(0,a.Lk)("code",null,"Integer.MAX_VALUE")])])]),(0,a.Lk)("div",{class:"content-item"},[(0,a.Lk)("h4",null,"3. Methoden-Bytecode"),(0,a.Lk)("ul",null,[(0,a.Lk)("li",null,"Kompilierter Code aller Methoden (JVM Bytecode)"),(0,a.Lk)("li",null,"Ausführungsinstruktionen für die JVM"),(0,a.Lk)("li",null,"Statische und Instanz-Methodenimplementierungen"),(0,a.Lk)("li",null,"Nativer Code-Verknüpfungen (JNI)")])]),(0,a.Lk)("div",{class:"content-item"},[(0,a.Lk)("h4",null,"4. Konstantenpool"),(0,a.Lk)("ul",null,[(0,a.Lk)("li",null,"String-Literale und numerische Konstanten"),(0,a.Lk)("li",null,"Symbolische Verweise auf Klassen und Methoden"),(0,a.Lk)("li",null,"Feld- und Methodennamen"),(0,a.Lk)("li",null,"Typ-Deskriptoren und Signaturen")])])]),(0,a.Lk)("div",{class:"example-box"},[(0,a.Lk)("h4",null,"Praktisches Beispiel:"),(0,a.Lk)("pre",{class:"code-example"},'public class MethodAreaExample {\n    // Statische Variable - in der Method Area gespeichert\n    public static int counter = 0;\n    \n    // Statische Konstante - in der Method Area gespeichert\n    public static final String APP_NAME = "Memory Visualizer";\n    \n    // Statische Methode - Bytecode in der Method Area\n    public static void incrementCounter() {\n        counter++;\n        System.out.println("Counter: " + counter);\n    }\n    \n    // Instanzmethode - Bytecode auch in der Method Area\n    public void printMessage(String message) {\n        // String-Literal "Message: " im Konstantenpool der Method Area\n        System.out.println("Message: " + message);\n    }\n    \n    public static void main(String[] args) {\n        // Ruft Code aus der Method Area auf\n        incrementCounter();\n        \n        // Erzeugt ein Objekt (im Heap),\n        // aber die Klasseninformation kommt aus der Method Area\n        MethodAreaExample example = new MethodAreaExample();\n        example.printMessage("Hello World");\n    }\n}'),(0,a.Lk)("div",{class:"example-explanation"},[(0,a.Lk)("p",null,[(0,a.Lk)("strong",null,"Was passiert im Hintergrund:")]),(0,a.Lk)("ol",null,[(0,a.Lk)("li",null,[(0,a.eW)("Beim Laden der Klasse "),(0,a.Lk)("code",null,"MethodAreaExample"),(0,a.eW)(" werden alle Klasseninformationen in der Method Area gespeichert.")]),(0,a.Lk)("li",null,[(0,a.eW)("Die statische Variable "),(0,a.Lk)("code",null,"counter"),(0,a.eW)(" wird in der Method Area initialisiert.")]),(0,a.Lk)("li",null,[(0,a.eW)("Die Konstante "),(0,a.Lk)("code",null,"APP_NAME"),(0,a.eW)(" wird im Konstantenpool abgelegt.")]),(0,a.Lk)("li",null,"Der Bytecode für alle Methoden wird in der Method Area gespeichert."),(0,a.Lk)("li",null,[(0,a.eW)("Beim Aufruf von "),(0,a.Lk)("code",null,"new MethodAreaExample()"),(0,a.eW)(" werden die Klasseninformationen aus der Method Area gelesen, um das Objekt im Heap zu erstellen.")])])])]),(0,a.Lk)("div",{class:"comparison-section"},[(0,a.Lk)("h3",null,"Method Area vs. Heap vs. Stack:"),(0,a.Lk)("div",{class:"table-container"},[(0,a.Lk)("table",{class:"comparison-table"},[(0,a.Lk)("thead",null,[(0,a.Lk)("tr",null,[(0,a.Lk)("th",null,"Speicherbereich"),(0,a.Lk)("th",null,"Gespeicherte Daten"),(0,a.Lk)("th",null,"Lebensdauer"),(0,a.Lk)("th",null,"Speicherverwaltung")])]),(0,a.Lk)("tbody",null,[(0,a.Lk)("tr",null,[(0,a.Lk)("td",null,[(0,a.Lk)("strong",null,"Method Area")]),(0,a.Lk)("td",null,"Klassenmetadaten, statische Variablen, Bytecode"),(0,a.Lk)("td",null,"Solange die Klasse geladen ist"),(0,a.Lk)("td",null,"Wird bei Klassenladen gefüllt, bei Klassenentladen geleert")]),(0,a.Lk)("tr",null,[(0,a.Lk)("td",null,[(0,a.Lk)("strong",null,"Heap")]),(0,a.Lk)("td",null,"Objekte, Arrays, Instanzvariablen"),(0,a.Lk)("td",null,"Solange Objekte referenziert werden"),(0,a.Lk)("td",null,"Garbage Collection")]),(0,a.Lk)("tr",null,[(0,a.Lk)("td",null,[(0,a.Lk)("strong",null,"Stack")]),(0,a.Lk)("td",null,"Lokale Variablen, Methodenparameter"),(0,a.Lk)("td",null,"Während der Methodenausführung"),(0,a.Lk)("td",null,"Automatisch bei Methodenende")])])])])]),(0,a.Lk)("div",{class:"flex-container"},[(0,a.Lk)("div",{class:"important-note"},[(0,a.Lk)("h4",null,"Wichtig zu wissen:"),(0,a.Lk)("ul",null,[(0,a.Lk)("li",null,[(0,a.Lk)("strong",null,"JVM-Spezifisch:"),(0,a.eW)(" Die genaue Implementierung der Method Area kann je nach JVM-Implementierung variieren.")]),(0,a.Lk)("li",null,[(0,a.Lk)("strong",null,"Permanente Generation:"),(0,a.eW)(' In älteren Java-Versionen war die Method Area Teil der "Permanent Generation". Ab Java 8 wurde sie durch den "Metaspace" ersetzt, der dynamisch wachsen kann.')]),(0,a.Lk)("li",null,[(0,a.Lk)("strong",null,"OutOfMemoryError:"),(0,a.eW)(' Wenn zu viele Klassen geladen werden, kann ein "OutOfMemoryError: Metaspace" auftreten.')]),(0,a.Lk)("li",null,[(0,a.Lk)("strong",null,"Klassenlader:"),(0,a.eW)(" Die Method Area wird durch Klassenlader (ClassLoader) befüllt, wenn neue Klassen benötigt werden.")])])]),(0,a.Lk)("div",{class:"summary-section"},[(0,a.Lk)("h3",null,"Zusammenfassung:"),(0,a.Lk)("p",null,'Die Method Area ist das "Wissensarchiv" der JVM. Sie enthält alle Informationen über Klassen, ihre Methoden, statische Variablen und Konstanten. Ohne die Method Area wüsste die JVM nicht, wie Objekte strukturiert sind oder wie Methoden ausgeführt werden sollen. Sie ist ein zentraler Bestandteil der Java-Speicherarchitektur und ermöglicht erst die Ausführung von Java-Programmen.')])]),(0,a.Lk)("h3",null,"Funktion im Gesamtsystem:"),(0,a.Lk)("p",null,"Die Method Area ist für die Laufzeitumgebung wichtig, da sie Informationen über Klassen und Methoden bereitstellt, die für die Ausführung benötigt werden. Im Gegensatz zum Heap, der Instanzen von Klassen speichert, enthält die Method Area die Klasseninformationen selbst.")],-1)]))),_:1})}var Qn={name:"MethodAreaTheory",components:{TheoryLayout:En},mounted(){}};const Xn=(0,k.A)(Qn,[["render",Gn],["__scopeId","data-v-7ed15831"]]);var Zn=Xn;function Nn(e,n,t,i,r,s){const l=(0,a.g2)("TheoryLayout");return(0,a.uX)(),(0,a.Wv)(l,{title:"Stack Pointer"},{default:(0,a.k6)((()=>n[0]||(n[0]=[(0,a.Lk)("div",{class:"theory-content"},[(0,a.Lk)("h2",null,"Was ist der Stack Pointer?"),(0,a.Lk)("p",null,"Der Stack Pointer (SP) ist ein spezielles Register in der JVM, das auf die aktuelle Position im Stack zeigt. Er ist wie ein Lesezeichen, das angibt, wo im Ausführungsstack wir uns gerade befinden."),(0,a.Lk)("div",{class:"visual-container"},[(0,a.Lk)("img",{src:"/images/theory/stack-pointer.png",alt:"Stack Pointer Visualisierung",class:"theory-image",onerror:"this.style.display='none'; document.getElementById('stack-pointer-fallback').style.display='block';"}),(0,a.Lk)("div",{id:"stack-pointer-fallback",class:"visual-fallback",style:{display:"none"}},[(0,a.Lk)("pre",null,"          ┌─────────────────────────┐\n          │  lokale Variable z = 7  │\n          │  lokale Variable y = 3  │\n          │  Parameter x = 5        │ ← Stack Pointer (SP)\n          ├─────────────────────────┤\n          │  Rücksprungadresse      │\n          │  lokale Variable b = 42 │\n          │  lokale Variable a = 10 │\n          └─────────────────────────┘\n                  ")])]),(0,a.Lk)("h3",null,"Funktionsweise des Stack Pointers:"),(0,a.Lk)("p",null,"Der Stack Pointer ist ein dynamischer Zeiger, der sich mit jedem Methodenaufruf und jeder Methodenrückkehr im Speicher bewegt."),(0,a.Lk)("div",{class:"function-steps"},[(0,a.Lk)("div",{class:"step"},[(0,a.Lk)("h4",null,"Bei Methodenaufrufen"),(0,a.Lk)("p",null,"Wenn eine Methode aufgerufen wird:"),(0,a.Lk)("ol",null,[(0,a.Lk)("li",null,"Wird ein neuer Stack-Frame erstellt"),(0,a.Lk)("li",null,'Der Stack Pointer "wandert" zum neuen Frame'),(0,a.Lk)("li",null,"Der neue Frame wird zum aktiven Ausführungskontext")])]),(0,a.Lk)("div",{class:"step"},[(0,a.Lk)("h4",null,"Bei Methodenrückkehr"),(0,a.Lk)("p",null,"Wenn eine Methode beendet wird:"),(0,a.Lk)("ol",null,[(0,a.Lk)("li",null,"Der aktuelle Frame wird entfernt"),(0,a.Lk)("li",null,'Der Stack Pointer "wandert zurück" zum vorherigen Frame'),(0,a.Lk)("li",null,"Die aufrufende Methode wird wieder aktiv")])])]),(0,a.Lk)("div",{class:"animation-container"},[(0,a.Lk)("h3",null,"Der Stack Pointer in Aktion:"),(0,a.Lk)("div",{class:"stack-animation-steps"},[(0,a.Lk)("div",{class:"animation-step"},[(0,a.Lk)("div",{class:"step-description"},[(0,a.eW)("1. "),(0,a.Lk)("code",null,"main()"),(0,a.eW)(" wird ausgeführt")]),(0,a.Lk)("pre",null,"          ┌─────────────────────────┐\n          │  lokale Variable n = 5  │ ← SP\n          ├─────────────────────────┤ \n          │  Stack Frame: main()    │ \n          └─────────────────────────┘\n                    ")]),(0,a.Lk)("div",{class:"animation-step"},[(0,a.Lk)("div",{class:"step-description"},[(0,a.eW)("2. "),(0,a.Lk)("code",null,"calculate(n)"),(0,a.eW)(" wird aufgerufen")]),(0,a.Lk)("pre",null,"          ┌─────────────────────────┐\n          │  Parameter x = 5        │\n          │  lokale Variable res = 0│ ← SP\n          ├─────────────────────────┤\n          │  Rücksprungadresse      │\n          │  lokale Variable n = 5  │\n          ├─────────────────────────┤ \n          │  Stack Frame: main()    │\n          └─────────────────────────┘\n                    ")]),(0,a.Lk)("div",{class:"animation-step"},[(0,a.Lk)("div",{class:"step-description"},[(0,a.eW)("3. "),(0,a.Lk)("code",null,"calculate()"),(0,a.eW)(" kehrt zurück")]),(0,a.Lk)("pre",null,"          ┌─────────────────────────┐\n          │  lokale Variable n = 5  │\n          │  lokale Variable res = 25│ ← SP (Ergebnis gespeichert)\n          ├─────────────────────────┤ \n          │  Stack Frame: main()    │\n          └─────────────────────────┘\n                    ")])])]),(0,a.Lk)("div",{class:"example-box"},[(0,a.Lk)("h4",null,"Praktisches Beispiel zur Stack Pointer Bewegung:"),(0,a.Lk)("pre",{class:"code-example"},'          public class StackPointerDemo {\n              public static void main(String[] args) {\n                  // SP zeigt auf den main()-Stack-Frame\n                  int number = 10;\n                  System.out.println("In main: " + number);\n                  \n                  // Methodenaufruf - SP wird auf firstMethod() bewegt\n                  int result = firstMethod(number);\n                  \n                  // SP zeigt wieder auf den main()-Stack-Frame\n                  System.out.println("Ergebnis: " + result);\n              }\n              \n              public static int firstMethod(int x) {\n                  // SP zeigt jetzt auf den firstMethod()-Stack-Frame\n                  int y = x * 2;\n                  System.out.println("In firstMethod: " + y);\n                  \n                  // Weiterer Methodenaufruf - SP bewegt sich zu secondMethod()\n                  int z = secondMethod(y);\n                  \n                  // SP zeigt wieder auf den firstMethod()-Stack-Frame\n                  return z + 5;\n              }\n              \n              public static int secondMethod(int a) {\n                  // SP zeigt jetzt auf den secondMethod()-Stack-Frame\n                  int b = a + 3;\n                  System.out.println("In secondMethod: " + b);\n                  \n                  // Rückkehr - SP geht zurück zum firstMethod()-Frame\n                  return b * 2;\n              }\n          }'),(0,a.Lk)("div",{class:"stack-visualization"},[(0,a.Lk)("p",null,[(0,a.Lk)("strong",null,"Stack Pointer Verschiebung während der Ausführung:")]),(0,a.Lk)("div",{class:"animation-steps"},[(0,a.Lk)("div",{class:"step"},[(0,a.Lk)("div",{class:"step-header"},"main() wird ausgeführt"),(0,a.Lk)("pre",null,"          ┌───────────────────┐\n          │ number = 10       │ ← SP hier\n          └───────────────────┘")]),(0,a.Lk)("div",{class:"step"},[(0,a.Lk)("div",{class:"step-header"},"firstMethod(number) wird aufgerufen"),(0,a.Lk)("pre",null,"          ┌───────────────────┐\n          │ x = 10            │\n          │ y = 20            │ ← SP bewegt hierher\n          ├───────────────────┤\n          │ number = 10       │\n          └───────────────────┘")]),(0,a.Lk)("div",{class:"step"},[(0,a.Lk)("div",{class:"step-header"},"secondMethod(y) wird von firstMethod aufgerufen"),(0,a.Lk)("pre",null,"          ┌───────────────────┐\n          │ a = 20            │\n          │ b = 23            │ ← SP bewegt hierher\n          ├───────────────────┤\n          │ x = 10            │\n          │ y = 20            │\n          ├───────────────────┤\n          │ number = 10       │\n          └───────────────────┘")]),(0,a.Lk)("div",{class:"step"},[(0,a.Lk)("div",{class:"step-header"},"secondMethod() kehrt zurück (b*2 = 46)"),(0,a.Lk)("pre",null,"          ┌───────────────────┐\n          │ x = 10            │\n          │ y = 20            │\n          │ z = 46            │ ← SP bewegt hierher zurück\n          ├───────────────────┤\n          │ number = 10       │\n          └───────────────────┘")]),(0,a.Lk)("div",{class:"step"},[(0,a.Lk)("div",{class:"step-header"},"firstMethod() kehrt zurück (z+5 = 51)"),(0,a.Lk)("pre",null,"          ┌───────────────────┐\n          │ number = 10       │\n          │ result = 51       │ ← SP bewegt hierher zurück\n          └───────────────────┘")])])])]),(0,a.Lk)("div",{class:"important-note"},[(0,a.Lk)("h4",null,"Wichtig zu wissen:"),(0,a.Lk)("ul",null,[(0,a.Lk)("li",null,[(0,a.Lk)("strong",null,"Thread-spezifisch:"),(0,a.eW)(" Jeder Java-Thread hat seinen eigenen Stack und damit auch seinen eigenen Stack Pointer.")]),(0,a.Lk)("li",null,[(0,a.Lk)("strong",null,"Nicht direkt zugreifbar:"),(0,a.eW)(" Im Gegensatz zu einigen Programmiersprachen ist der Stack Pointer in Java nicht direkt über Code manipulierbar.")]),(0,a.Lk)("li",null,[(0,a.Lk)("strong",null,"StackOverflowError:"),(0,a.eW)(" Wenn zu viele verschachtelte Methodenaufrufe erfolgen und der Stack seine maximale Größe erreicht, kann der Stack Pointer nicht weiter verschoben werden, was zu einem StackOverflowError führt.")]),(0,a.Lk)("li",null,[(0,a.Lk)("strong",null,"Performance:"),(0,a.eW)(" Da der Stack Pointer immer auf den aktiven Frame zeigt, ist der Zugriff auf lokale Variablen sehr schnell - ein wichtiger Leistungsvorteil.")])])]),(0,a.Lk)("div",{class:"summary-section"},[(0,a.Lk)("h3",null,"Zusammenfassung:"),(0,a.Lk)("p",null,"Der Stack Pointer ist ein essenzieller Mechanismus der JVM, der den aktuellen Ausführungskontext verfolgt. Er bewegt sich mit jedem Methodenaufruf und jeder Methodenrückkehr und ermöglicht so die strukturierte Abarbeitung von verschachtelten Methodenaufrufen. Ohne den Stack Pointer könnte die JVM nicht wissen, wo im Programm sie sich gerade befindet und welche Variablen zum aktuellen Kontext gehören.")]),(0,a.Lk)("h3",null,"Zusammenspiel mit dem Call Stack:"),(0,a.Lk)("p",null,"Wenn eine neue Methode aufgerufen wird, wird ein neuer Stack-Frame erstellt und der Stack Pointer wird aktualisiert, um auf diesen neuen Frame zu zeigen. Wenn die Methode beendet wird, wird der Stack-Frame entfernt und der Stack Pointer wird zurückgesetzt, um auf den vorherigen Frame zu zeigen.")],-1)]))),_:1})}var $n={name:"StackPointerTheory",components:{TheoryLayout:En},mounted(){}};const Un=(0,k.A)($n,[["render",Nn],["__scopeId","data-v-27e772f8"]]);var Yn=Un;function et(e,n,t,i,r,s){const l=(0,a.g2)("TheoryLayout");return(0,a.uX)(),(0,a.Wv)(l,{title:"Instruction Pointer"},{default:(0,a.k6)((()=>n[0]||(n[0]=[(0,a.Lk)("div",{class:"theory-content"},[(0,a.Lk)("h2",null,"Was ist der Instruction Pointer?"),(0,a.Lk)("p",null,"Der Instruction Pointer (auch Program Counter oder PC genannt) ist ein Register in der JVM, das auf die aktuelle oder nächste auszuführende Anweisung zeigt."),(0,a.Lk)("h3",null,"Aufgaben:"),(0,a.Lk)("ul",{class:"compact-list"},[(0,a.Lk)("li",null,"Er verfolgt den Fortschritt der Programmausführung"),(0,a.Lk)("li",null,"Er zeigt auf die nächste auszuführende Bytecode-Instruktion"),(0,a.Lk)("li",null,"Er wird nach jeder Instruktion aktualisiert")]),(0,a.Lk)("h3",null,"Programmflusssteuerung:"),(0,a.Lk)("p",null,"Der Instruction Pointer ist entscheidend für die Steuerung des Programmflusses. Bei Sprüngen, bedingten Anweisungen oder Schleifenausführungen wird der Instruction Pointer entsprechend angepasst, um auf die nächste auszuführende Anweisung zu zeigen."),(0,a.Lk)("h3",null,"Thread-spezifisch:"),(0,a.Lk)("p",null,"In Java hat jeder Thread seinen eigenen Instruction Pointer, damit mehrere Threads gleichzeitig an verschiedenen Stellen im Code ausgeführt werden können."),(0,a.Lk)("div",{class:"visual-container compact"},[(0,a.Lk)("img",{src:"/images/theory/instruction-pointer.png",alt:"Instruction Pointer Visualisierung",class:"theory-image",onerror:"this.style.display='none'; document.getElementById('instruction-pointer-fallback').style.display='block';"}),(0,a.Lk)("div",{id:"instruction-pointer-fallback",class:"visual-fallback",style:{display:"none"}},[(0,a.Lk)("pre",null,"┌─────────────────────────────────────┐\n│ Bytecode einer Methode:             │\n│                                     │\n│ 0: iload_1         // lade x        │\n│ 1: iload_2         // lade y        │\n│ 2: iadd            // addiere       │ ← Instruction Pointer\n│ 3: istore_3        // speichere z   │\n│ 4: iload_3         // lade z        │\n│ 5: ireturn         // kehre zurück  │\n│                                     │\n└─────────────────────────────────────┘\n          ")])]),(0,a.Lk)("h3",null,"Hauptaufgaben des Instruction Pointers:"),(0,a.Lk)("ul",{class:"compact-list"},[(0,a.Lk)("li",null,[(0,a.Lk)("strong",null,"Ausführungsverfolgung:"),(0,a.eW)(" Zeigt immer auf die nächste auszuführende Instruktion")]),(0,a.Lk)("li",null,[(0,a.Lk)("strong",null,"Kontinuität:"),(0,a.eW)(" Ermöglicht sequentielle Abarbeitung von Anweisungen")]),(0,a.Lk)("li",null,[(0,a.Lk)("strong",null,"Sprungsteuerung:"),(0,a.eW)(" Wird bei Verzweigungen (if/else), Schleifen und Methodenaufrufen angepasst")]),(0,a.Lk)("li",null,[(0,a.Lk)("strong",null,"Kontrolltransfer:"),(0,a.eW)(" Bei Exceptions oder return-Anweisungen wird er entsprechend aktualisiert")])]),(0,a.Lk)("div",{class:"comparison-note"},[(0,a.Lk)("h4",null,"Unterschied zum Stack Pointer:"),(0,a.Lk)("div",{class:"comparison-grid"},[(0,a.Lk)("div",{class:"comparison-item"},[(0,a.Lk)("h5",null,"Stack Pointer (SP)"),(0,a.Lk)("ul",{class:"compact-list"},[(0,a.Lk)("li",null,"Zeigt auf den aktuellen Stack-Frame"),(0,a.Lk)("li",null,"Verfolgt den Kontext der Methode"),(0,a.Lk)("li",null,"Bezieht sich auf den Call Stack"),(0,a.Lk)("li",null,"Ändert sich nur bei Methoden-Ein-/Austritt")])]),(0,a.Lk)("div",{class:"comparison-item"},[(0,a.Lk)("h5",null,"Instruction Pointer (IP)"),(0,a.Lk)("ul",{class:"compact-list"},[(0,a.Lk)("li",null,"Zeigt auf eine konkrete Anweisung"),(0,a.Lk)("li",null,"Verfolgt den Fortschritt in der Methode"),(0,a.Lk)("li",null,"Bezieht sich auf Bytecode-Anweisungen"),(0,a.Lk)("li",null,"Ändert sich bei jeder Anweisungsausführung")])])])]),(0,a.Lk)("div",{class:"instruction-animation"},[(0,a.Lk)("h3",null,"Der Instruction Pointer in Aktion:"),(0,a.Lk)("p",null,"Betrachten wir, wie sich der Instruction Pointer bei der Ausführung einer einfachen if-else-Struktur bewegt:"),(0,a.Lk)("div",{class:"code-with-ip"},[(0,a.Lk)("pre",{class:"code-example"},"public int vergleiche(int a, int b) {\n    if (a > b) {\n        return a;\n    } else {\n        return b;\n    }\n}"),(0,a.Lk)("div",{class:"bytecode-execution"},[(0,a.Lk)("p",null,[(0,a.Lk)("strong",null,"Vereinfachter Bytecode mit IP-Bewegung:")]),(0,a.Lk)("div",{class:"execution-steps"},[(0,a.Lk)("div",{class:"execution-step"},[(0,a.Lk)("div",{class:"ip-indicator"},"→"),(0,a.Lk)("code",null,"0: iload_1 // lade a")]),(0,a.Lk)("div",{class:"execution-step"},[(0,a.Lk)("div",{class:"ip-indicator"},"→"),(0,a.Lk)("code",null,"1: iload_2 // lade b")]),(0,a.Lk)("div",{class:"execution-step"},[(0,a.Lk)("div",{class:"ip-indicator"},"→"),(0,a.Lk)("code",null,"2: if_icmple 7 // wenn a <= b, springe zu 7")]),(0,a.Lk)("div",{class:"execution-step"},[(0,a.Lk)("div",{class:"ip-indicator"},"→"),(0,a.Lk)("code",null,"5: iload_1 // lade a")]),(0,a.Lk)("div",{class:"execution-step"},[(0,a.Lk)("div",{class:"ip-indicator"},"→"),(0,a.Lk)("code",null,"6: ireturn // kehre mit a zurück")]),(0,a.Lk)("div",{class:"execution-step"},[(0,a.Lk)("div",{class:"ip-indicator"},"→"),(0,a.Lk)("code",null,"7: iload_2 // lade b")]),(0,a.Lk)("div",{class:"execution-step"},[(0,a.Lk)("div",{class:"ip-indicator"},"→"),(0,a.Lk)("code",null,"8: ireturn // kehre mit b zurück")])])])])]),(0,a.Lk)("div",{class:"important-note"},[(0,a.Lk)("h4",null,"Wichtig zu wissen:"),(0,a.Lk)("ul",{class:"compact-list"},[(0,a.Lk)("li",null,[(0,a.Lk)("strong",null,"Unsichtbar für Entwickler:"),(0,a.eW)(" Der Instruction Pointer ist im Java-Code nicht direkt sichtbar oder manipulierbar.")]),(0,a.Lk)("li",null,[(0,a.Lk)("strong",null,"JVM-intern:"),(0,a.eW)(" Er wird ausschließlich von der JVM verwaltet, um den Ausführungsfluss zu steuern.")]),(0,a.Lk)("li",null,[(0,a.Lk)("strong",null,"Debug-Tools:"),(0,a.eW)(" Debugger können den aktuellen Instruction Pointer anzeigen, um die Programmausführung zu verfolgen.")]),(0,a.Lk)("li",null,[(0,a.Lk)("strong",null,"Multithreading:"),(0,a.eW)(" Bei Kontext-Wechseln zwischen Threads wird der jeweilige Instruction Pointer gespeichert und wiederhergestellt.")])])]),(0,a.Lk)("div",{class:"summary-section"},[(0,a.Lk)("h3",null,"Zusammenfassung:"),(0,a.Lk)("p",null,"Der Instruction Pointer ist ein fundamentales Konzept in der Programmausführung und ein wesentlicher Bestandteil der JVM-Architektur. Er steuert den Programmablauf, indem er stets auf die nächste auszuführende Anweisung zeigt. Ohne den Instruction Pointer könnte die JVM keine sequentielle Ausführung von Code oder bedingte Sprünge durchführen.")])],-1)]))),_:1})}var nt={name:"InstructionPointerTheory",components:{TheoryLayout:En},mounted(){}};const tt=(0,k.A)(nt,[["render",et],["__scopeId","data-v-2850b6a2"]]);var it=tt;const rt=[{path:"/",name:"welcome",component:fe},{path:"/visualizer",name:"visualizer",component:de},{path:"/theory",name:"theory",component:Me},{path:"/theory/callstack",name:"theory-callstack",component:Vn},{path:"/theory/memory-stack",name:"theory-memory-stack",component:_n},{path:"/theory/memory-heap",name:"theory-memory-heap",component:Tn},{path:"/theory/method-area",name:"theory-method-area",component:Zn},{path:"/theory/stack-pointer",name:"theory-stack-pointer",component:Yn},{path:"/theory/instruction-pointer",name:"theory-instruction-pointer",component:it},{path:"/quiz",name:"quiz",component:hn}],at=(0,g.aE)({history:(0,g.Bt)(),routes:rt});var st=at;const lt=(0,i.Ef)(m);lt.use((0,r.Ey)()),lt.use(st),lt.mount("#app")}},n={};function t(i){var r=n[i];if(void 0!==r)return r.exports;var a=n[i]={exports:{}};return e[i].call(a.exports,a,a.exports,t),a.exports}t.m=e,function(){var e=[];t.O=function(n,i,r,a){if(!i){var s=1/0;for(d=0;d<e.length;d++){i=e[d][0],r=e[d][1],a=e[d][2];for(var l=!0,o=0;o<i.length;o++)(!1&a||s>=a)&&Object.keys(t.O).every((function(e){return t.O[e](i[o])}))?i.splice(o--,1):(l=!1,a<s&&(s=a));if(l){e.splice(d--,1);var u=r();void 0!==u&&(n=u)}}return n}a=a||0;for(var d=e.length;d>0&&e[d-1][2]>a;d--)e[d]=e[d-1];e[d]=[i,r,a]}}(),function(){t.n=function(e){var n=e&&e.__esModule?function(){return e["default"]}:function(){return e};return t.d(n,{a:n}),n}}(),function(){t.d=function(e,n){for(var i in n)t.o(n,i)&&!t.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:n[i]})}}(),function(){t.g=function(){if("object"===typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"===typeof window)return window}}()}(),function(){t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)}}(),function(){var e={524:0};t.O.j=function(n){return 0===e[n]};var n=function(n,i){var r,a,s=i[0],l=i[1],o=i[2],u=0;if(s.some((function(n){return 0!==e[n]}))){for(r in l)t.o(l,r)&&(t.m[r]=l[r]);if(o)var d=o(t)}for(n&&n(i);u<s.length;u++)a=s[u],t.o(e,a)&&e[a]&&e[a][0](),e[a]=0;return t.O(d)},i=self["webpackChunkjava_speicherverwaltung"]=self["webpackChunkjava_speicherverwaltung"]||[];i.forEach(n.bind(null,0)),i.push=n.bind(null,i.push.bind(i))}();var i=t.O(void 0,[504],(function(){return t(1691)}));i=t.O(i)})();
//# sourceMappingURL=app.069bcab6.js.map